[ { "title": "记录一个写毕设的时候遇到的问题[2024-02-26]", "url": "/posts/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E5%86%99%E6%AF%95%E8%AE%BE%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-2024-02-26/", "categories": "编程, C++", "tags": "编程, C++", "date": "2024-02-26 00:00:00 +0800", "snippet": "今天在做毕设的时候，遇到了一个奇怪的运行时错误。问题经过简化，可以用以下几行代码在我的环境里触发问题。#include &amp;lt;typeindex&amp;gt; #include&quot;iostream&quot; #include &quot;unordered_map&quot; int main() { std::unordered_map&amp;lt;std::type_index, int&amp;gt; m; std::type_index key = typeid(int); std::cout &amp;lt;&amp;lt; key.name() &amp;lt;&amp;lt; std::endl; return 0; }在几次尝试后发现，使用Clion+CMake，在使用msvc Debug模式的情况下，能编译通过但是会出现运行时错误。（mingw64的Debug和Release模式都没问题）经过几个小时痛苦的瞎尝试后（包括删掉其他代码，删掉Boost库，去掉GTest框架），发现新建个项目，把原本的代码复制过去就能正常运行。感觉很可能不是我的问题 = =。今天又是被C++狠狠折磨的一天。" }, { "title": "《C++程序设计语言》笔记 第3章 C++概览：抽象机制", "url": "/posts/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-C++%E6%A6%82%E8%A7%88-%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/", "categories": "编程, C++", "tags": "编程, C++, 读书笔记", "date": "2023-04-09 00:00:00 +0800", "snippet": " 本笔记纯为个人使用而记录，只包含本人欠了解的知识点3.2 类P51C++最核心的语言特性就是类。类是一种用户自定义的数据类型，用于在程序代码中表示某种概念。无论何时，只要我们想为程序设计一个有用的概念、想法或实体，都应该设法把它表示为程序中的的一个类，这样我们的想法就能表达成代码，而不是仅存在于我们的头脑中、设计文档里或者注释里。三种重要的类： 具体类 抽象类 类层次中的类很多有用的的类都可以归为这三个类别，其他类也可以看成是这些类别的简单变形或组合。3.2.1 具体类型3.2.1.2 容器P54在某些情况下你不能使用回收功能，而且有的时候处于逻辑或性能的考虑你宁愿使用更精确地资源释放控制（见13.6.4节）。因此，我们迫切需要一种机制以确保构造函数分配的内存一定会被销毁，这种机制就叫做析构函数（destructor）。Vector的构造函数使用new运算符从自由储存（也称为堆或动态存储）分配一些内存空间，析构函数则使用delete运算符释放该空间以达到清理资源的目的。这一切都无需Vector的使用者干预。构造函数负责分配元素空间并正确地初始化Vector成员，析构函数则负责释放空间。这就是所谓的数据句柄模型（handle-to-data model），常用来管理在对象生命周期中大小会发生变化的数据。在构造函数中请求资源，然后在析构函数中释放它们的技术称为资源获取即 初始化（Resource Acquisition Is Initialization），简称RAII，它是的我们得以规避”裸new操作“、”裸delete操作的风险“。内存管理到用new申请堆内存3.2.1.3 初始化容器P55容器的作用是保存元素，因此我们需要找到一种便利的方法将元素存入容器中。为了做到这一点，一种可能的方式是先用若干元素创建一个Vector，然后再依次为这些元素赋值，显然这不是最好的办法，下面列举两种更简洁的途径。 初始化器列表构造函数（Initializer-list constructor）：使用元素的列表进行初始化； push_back()：在序列的末尾添加一个新元素。template&amp;lt;typename t&amp;gt; class Vector{ public: Vector(std::initializer_list&amp;lt;t&amp;gt;); void push_back(t);};用于定义初始化器列表构造函数的std::initializer_list是一种标准库类型，编译器可以辨识它：当我们使用{}列表时，如{1,2,3,4}，编译器会创建一个initializer_list类型的对象并将其提供给程序。因此，我们可以书写： Vector v1 = {1,2,3,4,5};Vector的初始化器列表构造函数可以定义成如下的形式：template&amp;lt;typename t&amp;gt;class Vector { private: t *p; public: Vector(std::initializer_list&amp;lt;t&amp;gt;); };template&amp;lt;typename t&amp;gt; Vector&amp;lt;t&amp;gt;::Vector(std::initializer_list&amp;lt;t&amp;gt; list):p{new t[list.size()]} { std::copy(list.begin(), list.end(), p); }3.2.2 抽象类型P56抽象类型(abstract type)将使用者与类的实现细节完全隔离开。class Container{public: virtual double&amp;amp; operator[](int) = 0; virtual int size() const = 0; virtual ~Container(){};};关键字virtual的意思是“可能随后在其派生类中重新定义”。我们把这种用关键字virtual生命的函数成为虚函数（virtual function）。看起来有点奇怪的 =0 说明该函数是纯虚函数。3.2.3 虚函数P58使用虚函数时，如何解析到正确的函数？常见的做法是编译器将虚函数的名字转换成函数指针表中对应的索引值，这张表就是所谓的虚函数表（virtual function table）或简称为vtbl。每个含有虚函数的类都有它自己的vtbl用于辨别虚函数。即使调用函数不清楚对象的大小和数据布局。vtbl中的函数也能确保对象被正确使用。调用函数的实现只需要知道Container中vtbl指针的位置以及每个虚函数对应的索引就可以了。这种虚调用机制的效率非常接近“普通函数调用”机制（相差不超过25%）。而它的空间开销包括两部分：如果类包含虚函数，则该类的每个对象需要一个额外的指针；另外每个这样的类需要一个vtbl。C++ - 多继承方式会产生多个虚函数表3.3 拷贝和移动当我们设计一个类时，必须仔细考虑对象是否会被拷贝以及如何拷贝的问题。3.3.1 拷贝容器P63类对象的拷贝操作可以通过两个成员来定义：拷贝构造函数（copy constructor）与拷贝赋值运算符（copy assignment） ： Vector(const Vector&amp;amp; a); //拷贝构造函数 Vector&amp;amp; operator=(const Vector&amp;amp; a); //拷贝赋值运算符3.3.2 移动容器P64我们能通过定义拷贝构造函数和拷贝赋值运算符来控制拷贝过程，但是对于大容量的容器来说拷贝过程有可能耗费巨大。事实上我们有时候并不真的想要一个副本；我们只想把计算结果从函数中取出来：相对于拷贝（copy）一个Vector对象，我们更希望移动（move）它。幸运的是，C++为我们的想法提供了支持： Vector(Vector&amp;amp;&amp;amp; a); //移动构造函数 Vector&amp;amp; operator=(Vector&amp;amp;&amp;amp; a); //移动复制运算符定义Vector移动构造函数的过程非常简单：Vector::Vector(Vector&amp;amp;&amp;amp; a) :elem{a.elem}, //从a中“夺取元素” sz{a.sz}{ a.elem = nullptr; //现在a已经没有元素了 a.sz = 0;}符号&amp;amp;&amp;amp;的意思是”右值引用“，我们可以给该引用绑定一个右值。标准库函数move()负责返回实参的右值引用。C++中move的使用3.3.4 抑制操作P66对于层次中的类来说，使用默认的拷贝或移动操作常常意味着风险。最好的做法是删除掉默认的拷贝和移动操作，也就是说，我们应该尽量避免使用这两个操作的默认定义：class Shape {public: Shape(const Shape &amp;amp;) = delete; Shape &amp;amp;operator=(const Shape &amp;amp;) = delete; Shape(Shape &amp;amp;&amp;amp;) = delete; Shape &amp;amp;operator=(Shape &amp;amp;&amp;amp;) = delete; ~Shape();};C++11新特性 使用=delete阻止拷贝类对象3.4 模板我们使用模板表示那些通过的概念，然后通过指定实参（比如指定元素的类型为double）生成特定的类型或函数。3.4.1 参数化类型P67例如：template&amp;lt;typename T&amp;gt;class Vector { //...}前缀template&amp;lt;typename T&amp;gt;指明T是该声明的形参，它是数学上“对所有T或”对所有类型T“的C++表达。为了让我们的Vector支持范围for循环，需要为之定义适当的begin()和end()函数：template&amp;lt;typename T&amp;gt;T *begin(Shape&amp;lt;T&amp;gt; &amp;amp;x) { return &amp;amp;x[0];}template&amp;lt;typename T&amp;gt;T *end(Shape&amp;lt;T&amp;gt; &amp;amp;x) { return begin(x) + x.size(); //这里和书中不同} 书中写的是 return x.begin() + x.size(); 似乎有问题？在类中定义：T *begin() { return &amp;amp;x[0];}T *end() { return this-&amp;gt;begin()+ this-&amp;gt;size();}模板是一种编译时的机制，因此与“手工编写的代码”相比，并不会产生任何内外的运行时开销。3.4.3 函数对象P69模板的一个特殊用途是函数对象（function object，有时也称为函子functor），我们可以像调用函数一样使用函数对象。3.4.4 可变参数模板P71定义模板时可以令其接收任意数量任意类型的实参，这样的模板称为可变参数模板（variadic template）。例如：template&amp;lt;typename T, typename... Tail&amp;gt;void f(T head, Tail... tail){ g(head); //对head做某些操作 f(tail...); //再次处理tail}实现可变参数模板的关键是：当你传给它多个参数时，谨记把第一个参数和其他参数区分对待。省略号...表示列表的“剩余部分”。另一个例子：auto max(auto &amp;amp;&amp;amp;x, auto &amp;amp;&amp;amp;...y) { if constexpr(sizeof...(y) == 0) return x; else { auto z = max(y...); return x &amp;gt; z ? x : z; }}或是反过来：auto max(auto &amp;amp;&amp;amp;...x, auto &amp;amp;&amp;amp;y) { if constexpr(sizeof...(x) == 0) return y; else { auto z = max(x...); return y &amp;gt; z ? y : z; }}3.4.5 别名P72在很多情况下，我们应该为类型或模板引入一个同义词。例如，标准库头文件&amp;lt;cstddef&amp;gt;包含别名size_t的定义： using size_t = unsigned int;其中size_t的实际类型依赖与具体实现，在另外一个实现中size_t可能变成unsigned long。使用size_t，程序员就能写出易于移植的代码。参数化的类型经常为与其模板实参关联的类型提供别名，例如：template&amp;lt;typename T&amp;gt;class Vector {public: using value_type = T; //...}通过绑定某些或全部模板实参，我们就能使用别名机制定义新的模板。例如：template&amp;lt;typename Key, typename Value&amp;gt;class Map { //...}template&amp;lt;typename Value&amp;gt;using String_map = Map&amp;lt;string, Value&amp;gt;;String_map&amp;lt;int&amp;gt; m;//m是一个Map&amp;lt;string,Value&amp;gt;;3.5 建议P73 直接用代码表达你的想法； 在代码直接定义类来表示应用中的概念； 用具体类表示那些简单的概念或性能关键的组件； 避免“裸的”new和delete操作； 用资源句柄和RAII管理资源； 当接口和实现需要完全分离时使用抽象类作为接口； 用类层次表示具有固有的层次关系的概念； 在设计类层次时，注意区分实现继承和接口继承； 控制好对象的构造、拷贝、移动和析构操作； 以值的方式返回容器（依赖于移动操作以提高效率）； 注意强资源安全，也就是说，不要泄露任何你认为是资源的东西； 使用容器保存同类型值的集合，将其定义为资源管理模板； 使用函数模板表示通用的算法； 使用包括lambda表达式在内的函数对象表示策略和动作； 使用类型别名和模板别名为相似类型或可能在实现中变化的类型提供统一的符号表示法；" }, { "title": "算法日寄[2022-08-06]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-08-06/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-08-06 00:00:00 +0800", "snippet": "牛客网训练赛第六次我做了AJMCodeforces Round #812 (Div. 2)D是我第一次遇见交互题，其实应该做出来的，没做出来有点可惜。" }, { "title": "算法日寄[2022-08-04]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-08-04/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-08-04 00:00:00 +0800", "snippet": "区间权值问题可以转化为将所有连续子序列的和分别乘以$w_i$然后求和，其中i表示子序列的长度。用$b_{i,j}$表示从j开始的一个长度为i的连续子序列的和，用$s_i$表示原数组的前缀和。所求的值可以表示为：\\[\\sum_{i=1}^n{\\sum_{j=1}^{n-i+1}{b_{i,j}w_i}}\\]$\\sum_{j=1}^{n-i+1}{b_{i,j}}$表示长度为i的所有子序列之和，用$c_i$表示。观察发现：\\[\\begin{aligned}c_1&amp;amp;=\\sum_{j=1}^{n}{b_{1,j}}=s_i\\\\c_i&amp;amp;=\\sum_{j=1}^{n-i+1}{b_{i,j}}\\\\&amp;amp;=(\\sum_{j=1}^{n-i+2}{b_{i-1,j}})+(\\sum_{j=i}^{n-i+1}a_j)\\\\&amp;amp;=c_{i-1}+s_{n-i+1}-s_{i-1}\\end{aligned}\\]递推求和即可,复杂度$O(n)$。Educational Codeforces Round 133 (Rated for Div. 2)七夕节上大分！C题差几分钟就能调出来了有点可惜。这次CD做出来的都只有一千出头，有点奇怪。" }, { "title": "算法日寄[2022-08-02]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-08-02/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-08-02 00:00:00 +0800", "snippet": "复习最长递增子序列，最长公共子序列。通知小弟题意是在有向图有n个点，其中m个点是源点的相邻点。问源点最少连接多少个相邻点可以使得源点和所有点相连。先dfs遍历一遍看相邻点全连接的情况下是否能连接到所有的点。如果不行，问题结束；如果可以，问题转化为源点最少连接多少个相邻点可以使得源点和所有相邻点相连。在m个点中跑dfs和并查集，首先每个邻接点初始化并查集，如果一个邻接点遍历到并查集的另一个根节点，将他的父节点设为自己。最后统计一下根节点的数量，完成。两次dfs可以合并成一次完成。复习强连通分量Tarjan。复习线段树、ST表。" }, { "title": "算法日寄[2022-08-01]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-08-01/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-08-01 00:00:00 +0800", "snippet": "牛客网训练赛第五次这次训练赛出了事故，题目过于简单，题面很多错误，给的样例都错了，测试数据也有错。赛后补题" }, { "title": "算法日寄[2022-07-31]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-31/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-31 00:00:00 +0800", "snippet": "牛客CodeTON Round 2 (Div. 1 + Div. 2, Rated, Prizes!)" }, { "title": "算法日寄[2022-07-30]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-30/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-30 00:00:00 +0800", "snippet": "牛客网训练赛第四次结束后4分钟把d过了，可惜。打了AtCoder Regular Contest 145" }, { "title": "算法日寄[2022-07-29]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-29/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-29 00:00:00 +0800", "snippet": "学k短路" }, { "title": "算法日寄[2022-07-28]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-28/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-28 00:00:00 +0800", "snippet": "小M和天平DP假的字符串按字典序大小排序（大小判断的时候额外进行一个循环判断）[NOI2000]单词查找树裸的字典树。" }, { "title": "算法日寄[2022-07-27]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-27/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-27 00:00:00 +0800", "snippet": "[NOIP1998]拼数排座椅看《算法竞赛入门到进阶》第一章到第五章" }, { "title": "算法日寄[2022-07-26]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-26/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-26 00:00:00 +0800", "snippet": "做了牛客235558学了状压dp做了P1896 [SCOI2005]互不侵犯做了P2704 [NOI2001] 炮兵阵地这两道都是状压dp，第二题炮兵阵地做了好久。，。方程推错了。" }, { "title": "算法日寄[2022-07-25]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-25/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-25 00:00:00 +0800", "snippet": "Codeforces Round #810 (Div. 2)结果：结束没多久想出了D的解法。早上补了D下午打了牛客网训练赛3" }, { "title": "算法日寄[2022-07-24]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-24/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-24 00:00:00 +0800", "snippet": "补了牛客网训练赛2 I是我想不到的dp。尝试做训练赛2 E 没做出来做了 NC16644很简单的一道模拟题，做只做了18分钟，结果wa了，看了十多分钟才发现是输出数组开小了。。做了 NC16622很简单的一道模拟题。做了NC16649分类是前缀和和差分，一眼看上去是区段合并的贪心，然后看数据范围发现直接暴力能过。先暴力过了一遍，然后离散化差分过了一遍。做了 牛客竞赛动态规划专题班树型dp例题 的B第一次写树状dp。Codeforces Round #810 (Div. 2)（未完待续:wink:）" }, { "title": "算法日寄[2022-07-23]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-23/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-23 00:00:00 +0800", "snippet": "牛客网训练赛第二次一题都没过。。结束后几分钟先补了G。然后补J：比赛时用c++被卡了精度，结束后用Python过了。看出题人讲解直播。尝试用c++过J，还没成功。" }, { "title": "算法日寄[2022-07-21]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-21/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-21 00:00:00 +0800", "snippet": "补了牛客网训练赛1 C训练赛的时候我没看这题。。将每个点遮住的区域画出，发现遮住的区域由从上下端点出发的线勾勒出，最前面的线的斜率有递增（递减）关系（并且b相同），所以只要遍历y，只要记住最大（最小）的斜率（而b相同）即可得到知道当前的最前面的那根线，然后算出有效点数量。遍历两遍y。做的过程中还遇到了double和int判定相等时精度问题（如果一根线刚好经过一个点，这个点不算有效的点），用一个1e-6的极小值加到double上解决（通过数据范围算出）。感觉不是很好的做法。。。" }, { "title": "算法日寄[2022-07-19]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-19/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-19 00:00:00 +0800", "snippet": "补了牛客网训练赛1 I打训练赛的时候没好好看题。。。一道概率dp，没怎么练过。看了题解补了。状态转移方程：" }, { "title": "算法日寄[2022-07-18]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-18/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-18 00:00:00 +0800", "snippet": "做了洛谷P1361（补网络流 3/50）看着题解做的，还做了好几天。需要构造出一个网络形状，把顶点分割为源点的点集和汇点的点集，前者里面的顶点表示种在第一个田，后者里面的顶点表示种在第二个田，最小割的割法得到的就是最大收益的割法。用Dinic（增广路径、弧优化）跑个最大流得到最小割，再用总的值减去最小割就是答案了。实在是很惊奇啊，原来最大流等于最小割的性质是这样用的。希望下次碰到最小割的题我能做出来。下午请假做了牛客网暑假训练赛的第一次（第一次品尝到了被中学生吊打的感觉）队友做了G，我参与做了A、D。一个半小时结束战斗，剩下三个半小时盯着题面和排行榜发呆。晚上看了出题人的讲解直播。" }, { "title": "算法日寄[2022-07-14]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-14/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-14 00:00:00 +0800", "snippet": "做了洛谷P1345（补网络流）网络流最小割问题，不过割的不是边而是顶点（第一次做没看清题结果就80分了）。" }, { "title": "算法日寄[2022-07-12]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-12/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-12 00:00:00 +0800", "snippet": "制作了引用算法日报源文件生成jekyll的post页面的模板，以后写完日报上传到我的个人博客更方便了。本来想把校赛H补了，但是发现自己网络流基础好差。。只能从基础学起了。" }, { "title": "算法日寄[2022-07-10]", "url": "/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E5%AF%84-2022-07-10/", "categories": "编程, 算法日记", "tags": "编程, 算法", "date": "2022-07-10 00:00:00 +0800", "snippet": "做了atcoder beginner contest259的D一道比较简单的题，解题方法是军训站军姿的时候想的XD。题意是若干个圆在二维平面上画出圆周，起点终点在圆周上，判断是否通过若干个圆周连接。简单几何+并查集（并查集换成广搜应该也没问题）第一次提交还报WA了，检查了半天最后还是看到atc提交记录里面的编译warning，我才知道lld的问题。。。。以后得多注意这种问题。" }, { "title": "《操作系统-CDIO之路》第四章存储管理 知识点总结", "url": "/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-CDIO%E4%B9%8B%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/", "categories": "编程, 操作系统", "tags": "编程, 操作系统, 读书笔记", "date": "2022-07-02 00:00:00 +0800", "snippet": "存储器是计算机系统的重要资源之一，由内存（主存储器）和外存（辅存储器）构成。内存储器（简称内存、主存、物理存储器）：处理机能直接访问的存储器。用来存放系统和用户的程序和数据，其特点是存取速度快，存储方式是以新换旧，断电信息丢失。价格昂贵外存储器（简称外存、辅助存储器）：处理机不能直接访问的存储器。用来存放用户的各种信息，存取速度相对内存而言要慢得多，但它可用来长期保存用户信息。在文件系统中介绍。价格便宜物理地址：把内存分成若干个大小相等的存储单元，每个单元给一个编号，这个编号称为内存地址（物理地址、绝对地址、实地址），存储单元占8位，称作字节（byte）。物理地址空间：物理地址的集合称为物理地址空间（主存地址空间），它是一个一维的线性空间。程序地址（逻辑地址 、虚地址 ）：用户编程序时所用的地址，基本单位可与内存的基本单位相同，也可以不相同。程序地址空间（逻辑地址空间、虚地址空间）:用户的程序地址的集合称为逻辑地址空间，它的编址总是从0开始的，可以是一维线性空间，也可以是多维空间。4.1 存储管理的基本功能4.1.1 转换用户通过汇编语言或高级语言编写的程序，称为源程序。源程序需要通过编译、连接、加载后才能运行。连接和加载连接可以分为两种方式：静态连接和运行时动态连接。静态连接：在程序运行之前，将各个目标模块及它们所需的库函数连接成一个完整的执行文件。静态链接需要将目标模块中使用的符号地址转换为可执行文件中使用的数字地址，静态链接需要： 修改相对地址 变换外部调用符号 运行时动态连接：指在程序运行时进行连接，通常被连接的共享代码称为动态连接库（DLL, Dynamic-Link Library）或共享库（Shared Library）。优点： 共享：多个进程可以共用一个 DLL，节省内存，减少文件交换 部分装入：一个进程可以将多种操作分散在不同的 DLL 中实现，而只将当前操作相应的 DLL 装入内存，加快程序的装入过程。 便于局部代码修改：便于代码升级和代码重用，只要函数的接口参数（输入和输出）不变，则修改函数及其 DLL，只需对可执行文件重新编译或连接 便于运行环境适应：调用不同的 DLL，就可以适应多种使用环境和提供不同功能。如：不同的显示卡只需厂商为其提供特定的 DLL，而 OS 和应用程序不必修改。缺点： 连接开销：增加了程序执行时的连接开销 管理开销：程序由多个文件组成，增加管理复杂度。 加载：绝对加载、可重定位加载和运行时动态加载。 绝对加载：要求加载模块总是被加载到主存中的同一个单元。因此，在提供给加载器的加载模块中，所有的地址访问必须是绝对地址。 可重定位加载：在加载时就把对主存的访问绑定到具体的主存地址。缺点是程序一旦装入内存后将不能再移动，且必须在程序执行之前将程序全部装入。 运行时动态加载：把对主存访问（绝对地址）的计算推迟到程序运行中真正需要时。基于这个目的，加载模块被加载到主存时，它的所有主存访问都以相对形式表示，只有一条指令真正被执行时才计算绝对地址。为确保该功能不会降低性能，这些工作必须由特殊的处理器硬件完成。地址转换地址转换：把进程的逻辑地址转换为内存的物理地址， 或称为重定位。 核心问题：把一维或多维的逻辑地址空间变换到内存一维的物理地址空间中，建立逻辑地址与物理地址的映射。实现地址转换的方式：静态地址重定位和动态地址重定位。静态地址重定位：程序装入内存时，由加载模块把进程中的指令地址全部转换为物理地址。动态地址重定位：在程序执行过程中，在CPU访问内存之前，将要访问的程序或数据地址转换成内存地址。动态地址重定位依靠硬件地址变换机构完成：地址重定位机构需要一个（或多个）基地址寄存器BR和一个（或多个）程序虚拟地址寄存器VR。内存地址MR与虚拟地址的关系为：MR=BR+VR。在动态地址重定位中，源程序、逻辑地址空间和物理地址空间的关系: 动态地址映射是由硬件在执行时完成的，程序中不执行的程序就不做地址映射的工作，这样节省了CPU时间。 重定位寄存器的内容由操作系统用特权指令来设置，比较灵活。 实现动态地址映射必须有硬件的支持，并有一定的执行时间延迟。现代计算机系统中都采用动态地址映射技术。 动态地址重定位可以对内存进行非连续分配 可以实现虚拟存储器 有利于程序段共享。4.1.2 存储保护和共享在多道程序设计的环境下，系统中有系统程序和多个用户程序同时存在，并且可能共享程序和数据，如何保证用户程序不破坏系统程序，用户程序之间不相互干扰？这就是存储保护所要解决的问题。常用的存储保护有三种： 硬件法：上下界保护法。 软件法：保护键法。为每个保护存储区分配一个保护键，可保护对该存储区的读写操作。保护键就是一个标志，标志能否被读写。 软件与硬件结合：界限寄存器与与CPU用户态或核心态工作方式结合。用户进程只能访问界限寄存器所规定的范围，核心态进程可以访问整个内存区域上下界寄存器保护法上下界寄存器保护法是一种硬件保护法：为每个进程设置一对装有程序起始地址和结束地址的上下界寄存器。在程序执行中，对内存的访问始终对所访问的地址进行检查，越界则产生中断。例： 有一程序装入内存的首地址是500，末地址是1500，访问内存的逻辑地址是500、345、1200。 下界寄存器：500 上界寄存器：1500 逻辑地址＋装入内存的首地址＝ 物理地址 1、500＋500 ＝ 1000 500 ≤ 1000 ≤ 1500 √ 2、345＋500 ＝ 845 500 ≤ 845 ≤ 1500 √ 3、1200＋500 ＝ 1700 500 ≤ 1700 ≤ 1500 ×保护键法保护键法是一种软件保护法： 为每一个被保护的存储块分配一个单独的保护键，在程序状态字中则设置相应的保护键开关字段，对不同的进程赋予不同的开关代码和与被保护的存储块中的保护键进行匹配。界限寄存器与CPU工作方式结合在这种方式下，用户态进程只能访问那些在界限寄存器所规定的的内存区域，而核心态进程则可以访问整个内存地址空间。UNIX系统就是采用这种保护方式。4.1.3 内存分配和回收存储管理要为每一个并发执行的进程分配内存空间，当进程执行结束时，要及时地回收该进程所占用的内存资源，以便给其他进程分配空间。内存的分配方式，可以分为三种：连续分配方式、离散分配方式和虚拟存储管理方式。 连续分配方式：为一个系统或用户程序分配一个连续的空间. 离散分配方式：将一个用户程序离散地分配到内存中的多个不相连续的区域中。以减少因连续分配所产生的碎片，提高内存的利用率。 虚拟存储管理方式：前两种分配方式，当进程大小超出内存的可用空间时，进程是无法运行的。为了解决这个问题，通过实现部分装入和部分对换功能，形成了虚拟存储管理方式。4.1.4 内存扩充内存扩充：把内存中不能运行的进程换出，或把外存中具备运行条件的进程换入内存。内存扩充的方式： 由应用程序控制的：覆盖方式； 由操作系统控制的：交换方式、请求调入方式和预调入方式。分区存储管理的优点： 支持多道程序设计，实现了多个进程对内存的共享。提高了内存和CPU的利用效率 分区存储管理的原理简单，所需硬件支持较少，容易实现分区存储管理的缺点： 分区存储管理要求进程在分区内连续存储，进程大小受内存空间容量的限制 分区存储管理难以实现存储共享 固定分区分配算法会产生内部碎片，动态分区分配算法会产生外部碎片，内存利用率不高4.2 分区存储管理分区管理的基本原理给装入内存的作业划分一块存储区域，以连续存储进程相关的全部指令和数据，若用户区中存在多个进程，则它们可以并发执行。分区管理是多道程序设计下的一种最简单的存储管理方法。分区管理的方法 固定分区法 动态分区法 4.2.1 固定分区固定分区(fixed partition)：把内存空间分成若干个大小不等的区域，称为分区。每个用户程序（作业、进程）调入内存后，占用其中一个分区，程序运行完成后释放该分区。操作系统占用其中一个分区。一旦划分完成，在系统运行期间内存不再重新划分，即分区的位置不可变，分区的个数不可变，分区的大小不可变。特点： 适用于多道程序系统和分时系统。 支持多个程序并发执行 难以进行内存分区的共享。问题：可能存在内碎片和外碎片。 内碎片：占用分区之内未被利用的空间 外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）。4.2.2 动态分区动态分区，又称变长分区，指根据进程大小，动态地为之分配内存空间。可以克服固定分区中小进程占据大分区的现象，避免分区内部出现碎片，提高内存空间的有效利用率。在进程进入内存前并不建立分区，而是根据进程大小对内存进行划分，因此，内存中分区个数是可变的。在动态分区下，系统初启时，用户区是一个大区域。随着进程的执行，内存空间将被划分成许多个分区。当新进程将被装入时，判断用户区的空闲区域是否足够大，如果大于进程需求量，则将空闲区按进程大小分成两个部分，一部分分配给进程，另一部分又称为一个较小的空闲区。随着时间的推移，内存空间中会产生越来越多的碎片，这种现象称作外部碎片。为了减少外部碎片的浪费，必须对空闲区进行紧凑（或称拼凑，Compaction）——通过移动，把分散的多个小分区拼接成大分区。即向一个方向（例如向低地址端）移动已分配的进程，使那些零散的小空闲区在另一方向连成一片。动态分区管理中何时对内存空间进行紧凑： 在某个分区被释放后立即进行紧凑 当请求分配找不到足够大的自由分区分给用户时，使用紧凑 4.2.3 地址转换和存储保护固定分区存储管理的地址转换可以采用静态地址重定位和动态地址重定位。静态地址重定位：在进程装入前，进行地址转换，并检查其物理地址是否在分区的指定长度中，若是，则装入，否则发生地址越界，不能装入。动态地址重定位：当一个进程被 CPU 执行时，操作系统从分区说明表中根据占有标志取出其相应的起始地址和分区长度，分别置入上限/下限寄存器；在执行过程中，硬件的地址转换机构根据下限寄存器中的值 B 与指令的逻辑地址相加后得到物理地址，同时将物理地址与上限寄存器中的值进行比较，若在分区长度内，则执行指令；否则，产生一个中断，表明地址越界，从而实现存储保护。4.2.4 存储共享无论是固定分区，还是动态分区，进程在各个分区内都是连续存储的，因而不允许各个分区之间有公共区域。当几个进程共享某些指令和数据时，各个进程只能在各自分区内各放一个副本。因此，分区存储管理难以实现各分区间的信息共享。4.2.5 分配和回收算法分配：存储管理程序根据请求表查询分区说明表，从中找出一个满足要求的空闲分区，并将其分配给申请者。固定分区的分配动态分区的内存分配算法对于动态分区的内存分配算法，当一个进程将被装入时，若内存中存在多个空闲区，则操作系统必须考虑分配哪个分区。这属于分配策略的问题，通常考虑的方式有三种： 最先适应法(first fit algorithm) 最佳适应法(best fit algorithm) 最坏适应法(worst fit algorithm)。最先适应法 将空闲分区表中的表项按起始地址的递增顺序排列 每次分配时，根据进程大小，算法从分区说明表的表头开始顺序查找，找到第一个大于或等于进程大小的空闲区，则停止查找 从所找到的分区中划出所要求的内存长度给用户 如果余下部分有相邻空闲区存在，则使用紧凑对其合并后重新进入可用分区表，并修改调整分区说明表最先适应法的目的在于减少查找时间，具有以下特点： 该算法分配分区和释放分区的时间性能较好，较大的空闲分区可以被保留在内存高端； 随着低端分区不断划分而产生较多小分区，每次分配时查找时间开销会增大。最佳适应法 将空闲分区表的表项按从小到大的递增次序排列 每次分配时，根据进程大小，算法从分区说明表的表头开始顺序查找，找到第一个大于或等于进程大小的空闲区，则停止查找 从所找到的分区中划出所要求的内存长度给用户 如果余下部分有相邻空闲区存在，则使用紧凑对其合并后重新进入可用分区表，并修改调整分区说明表最佳适应法的目的在于使碎片尽量小。它从全部空闲区中找出能满足进程要求的、且为最小的空闲区。最佳适应算法具有以下特点： 从局部来看，外碎片较小 从整体来看，会形成较多外碎片 较大的空闲区可以被保留。最坏适应法 将空闲分区表按从大到小的递减顺序排列 每次分配时，根据进程大小，算法从分区说明表的表头开始顺序查找。若第一个空闲区的大小就小于进程大小，则分配失败。否则，找到第一个大于或等于进程大小的空闲区，则停止查找 从所找到的分区中划出所要求的内存长度给用户 如果余下部分有相邻空闲区存在，则使用紧凑对其合并后重新进入可用分区表，并修改调整分区说明表几种分配算法的比较 算法 最先适应法(first-fit)： 最佳适应法(best-fit)： 最坏适应法(worst-fit)： 优点 该算法的分配和释放的时间性能较好。不需要对空闲区进行排队，在释放时不必重新调整空闲区的位置。 能找到最佳空闲区，从个别来看，内碎片较小，较大的空闲分区可以被保留。 基本不留下小空闲分区。 缺点 随着低端分区不断划分而产生较多小分区，每次分配时查找时间开销会增大。 从整体来看，会形成较多外碎片。而且这些外碎片很难再被利用。 分配和回收时有很大查找负担。 较大的空闲分区不被保留。 分配和回收时有很大查找负担。 动态分区的回收算法回收：当进程执行完毕，不再需要内存资源时，管理程序将对应的分区状态置为未使用。当一个进程运行结束释放内存时，系统根据释放区的首地址，从空闲分区表中找到相应的插入点，此时可能出现下图所示的四种情况，其中 F 1 ，F 2 表示回收区的前、后空闲区。移动技术当在空闲分区表中找不到一个足够大的空闲区来装入进程，而所有剩余空闲区的大小却能容纳时，就可采用移动技术，改变内存中进程的存放区域，从而使分散的空闲区汇集成一片，便于进程装入。移动技术实质是为了提高内存利用率，对相邻的空闲区进行拼接，从而得到更大的空闲区。4.2.6 覆盖和交换覆盖与交换是解决大进程与小内存矛盾的两种存储管理技术，实质上是对主存进行了逻辑扩充。覆盖技术主要用于早期的操作系统中；交换技术仍用于今天的操作系统。覆盖技术覆盖(overlay)技术指：同一主存区可以被不同的程序段重复使用。引入：其目标是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用。原理：一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。 将程序的必要部分（常用功能）的代码和数据常驻内存 可选部分（不常用功能）在其他程序模块中实现，平时存放在外存中（覆盖文件），在需要用到时才装入到内存 不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。(即不同时用的模块可共用一个分区)交换技术交换技术是指：操作系统根据需要把主存中暂时不运行的某个进程移动到外存交换区，从而获得空闲内存空间来装入新程序，然后把外存交换区中的某个进程移到相应的主存区，并使其投入运行。常用于多道程序系统或小型分时系统中，与分区存储管理配合使用。又称作”对换”或”滚进/滚出(roll-in/roll-out)”；交互过程中，交换单位为整个进程的地址空间。将整个进程的地址空间保存到外存的交换区中（换出swap out）而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，并将该进程送到就绪队列（换入swap in）。4.2.7 分区存储管理的优缺点分区存储管理的优点： 支持多道程序设计，实现了多个进程对内存的共享。提高了内存和CPU的利用效率 分区存储管理的原理简单，所需硬件支持较少，容易实现 分区存储管理的缺点： 分区存储管理要求进程在分区内连续存储，进程大小受内存空间容量的限制 分区存储管理难以实现存储共享 固定分区分配算法会产生内部碎片，动态分区分配算法会产生外部碎片，内存利用率不高4.3 分页式存储管理提出分页式存储管理的原因： 分区管理方式存在着严重的碎片问题使得内存的利用率不高。 进程的大小仍受分区大小或内存可用空间的限制。 分区管理不利于程序段和数据的共享。4.3.1 基本原理 各进程的虚拟地址空间被划分成若干个长度相等的页（page）。页长的划分和内存外存之间数据传输速度以及内存大小等有关，一般为1-4K。 物理内存空间也按页的大小划分为页面（page frame）。这些页面为系统中的任一进程所共享。 分页管理把页式虚拟地址与内存物理地址建立一一对应的页表，并用相应的硬件地址变换机构，来解决离散地址变换。 分页式存储管理允许把一个进程分配到不相邻的分区中。这种方式实现了程序的不连续存储，避免产生外部碎片，充分利用了内存空间。 经过页划分后，进程的虚地址变为页号与页内地址所组成。分页管理时，用户进程在内存空间中除了在每个页面内地址连续之外，每个页面之间不再连续。第一是避免产生外部碎片，充分利用了内存空间。第二是实现了由连续存储到非连续存储的飞跃，为在内存中局部地，动态地存储那些反复执行或即将执行的程序和数据打下了基础。4.3.2 数据结构分页式管理在进程开始执行之前，把该作业或进程的程序段和数据全部装入内存的各个页面内，并通过页表和硬件地址变换机构，实现逻辑地址（虚地址）到物理地址的转换。 页表：记录页号与页面号的对应关系页表是操作系统为每个用户进程建立的，在内存中占有一块固定的区域。页表用来记录程序页和内存页面的一一对应关系。每个页在页表中占一个表项，记录该页在内存中对应的物理页面。 作业表：记录正在运行作业的页表地址作业表是操作系统为当前运行的所有作业建立的，用来记录每个作业的页表起始地址和页表长度，以进行内存分配和地址变化。整个系统一张作业表。 存储页面表：记录内存分配情况存储页面表也是操作系统建立的，用来记录内存分配情况，指出已分配的页面和尚未分配的页面。整个系统一张存储页面表。存储页面表的两种实现方法 ：1、位示图法；2、链表法。 位示图法：在内存中划分一块固定区域用于存放此表，表格中的每一位代表一个页面，如果该页面已被分配，则对应表格设置为 1，否则设置为 0。 链表法：表中每一项都含有以下内容：进程占用区(P)或者空闲区(H)、页表起始地址、页表长度和指向下一表项的指针。4.3.3 地址转换和存储保护地址转换采用动态地址重定位。调度程序在选择作业后，从作业表的登记项中得到被选中作业的页表起始地址和页表长度，将其送入硬件设置的页表控制寄存器。地址转换时，先从页表控制寄存器中找到相应的页表，再以页号为索引从页表中找到对应的页面号，并根据下列公式计算出要访问内存单元的物理地址：物理地址 = 页面号 × 页面长度 + 页内地址分页式管理的存储保护两种方式： 地址越界保护。在进行地址变换的过程中，将页号与页表长度进行比较，如果页号大于页表长度，则越界中断。 通过页表控制对内存信息的操作方式以提供保存。在页表中增加一些标志位，用来定义该页面的相关授权操作：只读、读写、只写、只可执行等。若试图向只读页面中写入信息，则指令会停止执行，并产生中断信号。4.3.4 分配算法4.3.5 存储共享分页式存储管理能实现多个进程共享程序和数据 ，但在共享时，必须区分数据共享和程序共享。数据共享时，允许不同的进程对共享的数据页使用不同的页号，但要确保各个进程页表中的有关表目都指向共享的数据页面块。程序共享时，必须保证代码是可重入代码。可重入代码是一种允许多个进程同时访问的代码，是一种不允许任何进程对其进行修改的代码。但在每个进程中，配以局部数据区，将在执行中可能改变的部分，复制到该数据区。当程序执行时，只对该数据区（进程私有）中的内容进行修改，而不去改变共享的代码，这时的可共享代码即成可重入代码。4.3.6 分页式存储管理的优缺点优点： 不要求各个页面之间连续存储，实现了离散存储，可以避免产生外部碎片。 实现了由连续存储到非连续存储的飞跃，为在内存中局部、动态地存储那些反复执行或即将执行的程序和数据打下了基础，也为以后实现程序的“部分装入、部分对换”奠定基础。缺点： 消除了外部碎片，但内部碎片仍然存在 分页式存储管理在进行地址转换和存储保护时，需要有相应的硬件支持，增加了机器成本4.4 分段式存储管理4.4.1 基本原理在分区存储管理和分页式存储管理中，进程的逻辑地址空间按线性排列。虽然把程序划分成区或页，但这些区或页与源程序的公用子程序和数据毫无逻辑关系。而共享程序或数据往往按照程序名或数据块调用，所以不同进程之间共享公用子程序和数据变得非常困难。为了更好地实现公用子程序和数据的共享，把用户进程按逻辑关系划分成若干个段，每个段有自己的名字，从零开始编址。分段式存储管理：以段为基本单位，对进程进行划分，要求每一段分配一个连续的存储空间，而各段之间不一定连续。每段都有逻辑名、并具有完整的逻辑意义 。一个程序可以分为若干程序段：主程序段、若干子程序段、若干数据段，每段的地址都从“0”开始编址，每段都有逻辑名、并具有完整的逻辑意义。对源程序进行编译、连接时，分段式存储管理要求把进程的逻辑地址空间设计为二维结构，即段号和段内地址 。与分页式存储管理相比，分段式存储管理有两个显著的特征： 在分页式存储管理中，内存中的页面号递增排列，地址空间属于一维结构。而在分段式存储管理中，段号在内存中的分区之间无任何顺序关系，地址空间属于二维结构 在分页式存储管理中，每个页的长度固定。而在分段式存储管理中，为了确保信息在逻辑上是完整的，段的长度可变。分段式存储管理为进程的每一段分配一个连续内存空间，而各个段之间并不要求一定连续4.4.2 地址转换和存储保护地址转换为了实现地址变化，将进程的逻辑地址（二维）转换为物理地址（一维），操作系统为每个进程建立一张段映射表，简称为“段表”。段表实现从逻辑段到物理内存区的映射。 段号 始址 段长 存取方式                 为实现缺段中断处理和存储保护，段表增加了两个字段：段号、存取方式。段号与用户指定的段名一一对应；始址和段长分别表示该段在内存或外存的物理地址与实际长度；存取方式用来对该段进行存取保护。调度程序从作业表中得到被选中作业的段表起始地址和段表长度，将其送入硬件设置的段表控制寄存器。 作业名 段表起始地址 段表长度 A 1024 40 B 1064 40 C 1104 60 地址转换时，从段表控制寄存器中找到相应的段表，然后以虚地址的段号 s 为索引，从段表中找到相应的表目。若该段在内存中，则将其起始地址和段内相对地址相加，得到该段在内存中的实际物理地址。若该段不在内存中，则产生缺段中断将 CPU 控制权交给内存分配程序。内存分配程序首先检查空闲区链表，以确定能否找到足够长度的空闲区来装入所需要的段。如果不能找到，则检查段表中的访问位，淘汰那些访问概率低的段，并根据外存的始址将该段调入。分段式存储管理的地址变换需要访问内存二次：第一次先访问段表以计算得到待访问指令或数据的物理地址，然后才对物理地址进行取数据或存数据。储存保护 地址越界保护法：利用段表中的段长项与虚拟地址中的段内相对地址比较，确定是否越界。若段内地址大于段长，则系统会产生保护中断。但在允许段长动态增长的系统中，段内相对地址可以大于段长。 存取方式控制保护法4.4.3 储存共享分段式存储管理，支持按段名访问内存空间=&amp;gt;更好地实现内存信息共享段的共享：多个用户进程通过使用相同的段名，在新的段表中填入共享段的起始地址，并置以适当的读写控制权，就可以共享一段逻辑上完整的程序和数据。当多个进程并发执行共享段时，共享段不能被修改，并且不能将正在或将要执行的共享段换出内存，这个机制可以通过在段表中设置共享位来实现。4.4.4 分段式存储管理的优缺点优点： 有利于实现信息共享 动态增长：段长可根据需要动态增长 动态连接：当运行过程中需要调用某段时，再将该段（目标程序）调入内存并连接起来。动态连接是以段为基础的 提供了内外存统一管理的虚拟存储器的实现缺点： 需要有更多的硬件支持，提高了机器成本 在内存空闲区管理方式上与分区式存储管理相同，存在碎片问题 缺段中断处理、动态增长会给系统增加难度和开销，有可能会产生抖动现象抖动：由于置换算法选择不当，导致整个系统调度非常频繁，大部分时间都花在内存和外存之间的来回调入调出上，这个现象称为抖动。4.5 段页式存储管理4.5.1 基本原理分段是信息的逻辑单位，由源程序的逻辑结构决定，用户可见，段长可根据用户需要来动态增长。因此，分段式存储管理是基于用户程序结构的存储管理技术，有利于模块化程序设计，有利于段的动态增长及共享和内存保护 ，但往往会产生碎片问题。分页是信息的物理单位，与源程序的逻辑结构无关，用户不可见，页长不可动态改变。分页式存储管理是基于系统存储器结构的存储管理技术，可以避免产生外部碎片，提高了内存的利用率，但不易实现存储共享。段页式管理将段式管理和页式管理结合起来，取长补短。内存：将整个内存划分成大小相等的、位置固定的页面。进程：将一个进程中所包含的具有独立逻辑功能的程序或数据划分成段，并为每个段赋予一个段名。把每段的线性地址空间划分成与页面大小相等的页，和页式管理一样，最后不足一页的部分仍占一页。段页式管理中，进程的虚拟地址由三部分组成：段号s，段内页号p，页内相对地址d：对程序员而言，虚拟地址仍可视为由段号s和段内相对地址w组成，地址变换机构会把w的高几位解释为段内页号p，把剩下的部分解释为页内位移d。满足w = p×块长 + d段页式存储管理的数据结构，包括作业表、段表和页面三级结构。整个系统一张作业表，用于记录系统中所有作业的段表的起始地址；每个作业一张段表，用于记录该作业的所有段以及每段的页表起始地址；每个段一张页表，把段中的虚页变换成内存中的实际页面。段页式管理系统中，如果要对内存中的指令或数据进行一次存取，至少需要访问三次以上的内存：第一次：由段表地址寄存器得到段表始址去访问段表，由此取出对应段的页表地址；第二次：访问页表得到所要访问的物理地址；第三次：访问真正的内存物理单元。4.5.3 段页式存储管理的优缺点优点：段页式存储管理具有分页式存储管理和分段式存储管理的优点。缺点：所需的硬件支持、复杂性和系统开销也会随之增加。在地址转换过程中，如果不采用快表提高地址转换速度，那么CPU的执行速度将大大下降。为了提高地址转换速度，设置快速联想寄存器，存放当前最常用的段号s，页号p和对应的内存页面与其他控制项目。如果所要访问的段或页在快速联想寄存器中，则系统不再访问内存中的段表、页表而直接把快速联想寄存器中的值与页内相对地址拼接起来得到物理地址。经验表明，一个在快速联想寄存器中装有1/10左右的段号、页号及页面的系统，可以得到90%的命中率。4.6 虚拟存储管理4.6.1 虚拟存储器的概念部分装入：当一个进程在执行过程中，若需要访问的指令和数据不在内存中，则系统把这部分信息自动调入内存，称为部分装入。部分对换：若内存中没有足够多的空闲区，则系统需把内存中暂时不用的信息从内存中调出，称为部分对换。虚拟存储器：系统自动实现部分装入和部分对换功能，只把进程的一部分装入内存便可运行，从逻辑上，是对内存容量进行了扩充的一种虚拟存储器，简称虚存。虚拟存储管理采用以下几种技术实现：请求分页式虚拟存储管理、请求分段式虚拟存储管理、请求段页式虚拟存储管理。4.6.2 请求分页式虚拟存储管理基本原理请求分页式虚拟存储管理（请求页式管理），是在分页式存储管理的基础上，增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许只装入若干页（而非全部程序）的用户程序和数据，就可启动运行，执行过程中再通过调页功能和页面置换功能，陆续把将要运行的页面调入内存，同时把暂不运行的页面置换到外存上，调入和置换均以页面为单位。根据页面调入的时机不同分为两种方式：请求页式管理和预调入页式管理。 请求页式管理：当需要执行某条指令或访问某个数据时，发现它们不在内存中，发生缺页中断，系统从外存中把该指令或数据所在的页面调入内存。 预调入页式管理：一种主动的缺页调入策略。在进程运行过程中，动态预测进程所需要的页面，预先调入内存中，尽量确保进程所需的页面都已调入。地址变换请求页式管理的地址转换和存储保护与分页式管理的地址转换和存储保护基本相同，只是在请求页式管理时，由于只调入立即或经常使用的程序和数据，在进程执行过程中，不可避免地会产生缺页中断，要从外存中调入所需的程序和数据。因此，如何处理缺页中断，以及如何从内存中换出页，是请求页式管理必须解决的两个基本问题。第一个问题的解决办法是扩充页表的内容。在页表原有页号和页面号的基础上，增加驻留标志位、外存始址和其他标志。解决第二个问题的基本思路：当发生缺页中断时，需要根据所缺页的外存始址将该页从外存调入内存，如果内存中没有空闲页面，则应该使用置换算法选择一个页面淘汰，如果这个页面被写过或修改过，则应该把淘汰页的内容写回外存加以保存，在成功调入所缺页后， 应同时修改进程页表的相应表项。快表是一块小容量的相联存储器（Associative Memory），由高速缓存器组成，速度快，并且可以从硬件上保证按内容并行查找，一般用来存放当前访问最频繁的少数活动页面的页号。快表的用途是加快线性地址的转换。页面分配策略页面分配是指在内存中为进程分配页面（分配存储空间）。固定分配：保持页面数固定不变，只要发生一个缺页中断，就会有一页被替换掉。主要有： 平均分配算法; 按比例分配算法 优先权分配算法：把内存中可供分配的所有物理块分成两部分，一部分按比例分配给各进程，另一部分则根据各进程的优先权，适当地增加其相应份额 后，分配给各进程。可变分配：进程生命周期中，分配的页面数可变。被许多操作系统使用，但困难于OS需要经常监视活动进程的缺页中断率，增加操作系统的开销。页面置换策略页面置换是指对于请求页式管理，当进程执行产生缺页中断时，需要从外存把缺页调入内存，若内存空间已满无空闲页面时，则必须按一定的策略把内存中的某个页面调出，这个工作称为页面置换。局部替换：页面置换算法从属于进程自己的页面中选择一个替换页面，其作用范围是本进程。全局替换：页面置换算法从所有的页面中选择一个替换页面，其作用范围是整个系统。页面置换算法置换算法的选择很重要，应该将那些访问概率最低的页调出内存。如果选择不当，容易产生抖动。理想的置换算法，理想型淘汰算法OPT (Optimal replacement algorithm) ：当要从外存调入一个缺页而必须从内存中淘汰一个页面时，所淘汰的页应该是以后不再访问的页或距现在最长时间内不再访问的页。又称为最佳替换算法（Optimal）。特点：无法预测进程的访问串，因而无法实现。常用的置换算法： 随机页面置换算法：所淘汰页面由随机程序产生的随机数决定。 先进先出页面置换算法（FIFO）：基于程序按线性顺序来访问物理空间这一假设，总是选择在内存中驻留时间最长的一个页面进行淘汰。 最近最久未使用页面置换算法（Least Recently Used,LRU）:总是选择最近一段时间内最久没有使用过的页先淘汰。这种算法在操作系统、数据管理系统和文件系统中被广泛使用。先进先出页面置换算法（FIFO）实现FIFO算法，需要把各个已分配的页面按分配时间顺序链接起来，组成FIFO队列，并设置一个置换指针指向FIFO的队首页面。例1：进程P共有5页，其页面走向（访问串）为：1，2，3，4，1，2，5，1，2，3，4，5，若开始执行时主存中没有页面，如果分配给该进程的物理块数为 4 时，采用先进先出（FIFO）页面置换算法时的缺页次数和缺页率各是多少？（缺页次数就是缺页中断次数。缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问）例2：假设同前，如果分配给该进程的物理块数为 3 时，采用先进先出（FIFO）页面置换算法时的缺页次数和缺页率各是多少？FIFO算法的Belady现象在使用FIFO算法时，在未给进程分配它所要求的足够页面数时，有时会出现分配的页面数增多，缺页次数反而增加的奇怪现象，这种现象称为Belady现象。原因在于没有考虑到程序执行的动态特征。最近最久未使用页面置换算法（Least Recently Used,LRU）算法主要出发点：如果某页很长时间未被访问，则它在最近一段时间内也不会被访问。算法实现较困难，因为必须为每个页面设置有关的访问记录项，且每次访问都必须更新记录。抖动置换算法的选择很重要，应该将那些访问概率最低的页调出内存。如果选择不当， 有可能产生被调出内存的页又要马上调入内存，调回内存不久后马上又要被调出内存，如此反复的局面，使得处理器花费大量时间用于调换页面而不是执行计算任务，这种现象被称为 “抖动”(Thrashing)，又称“颠簸”。4.6.3 请求分段式虚拟存储管理基本原理请求分段式虚拟存储管理（请求分段式存储管理，请求分段管理）是在分段式存储管理的基础上，增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统。它把进程所有分段的副本都存放在辅助存储器中，当进程运行时，首先只装入若干段（而非全部信息）的指令和数据，执行过程中再通过调段功能和置换功能，陆续把将要运行的段调入内存，同时把暂不运行的段置换到外存上，调入和置换均以段为单位。为了实现请求分段式存储管理，在分段式存储管理的段表中需要增加若干项，以供系统在调入、调出时参考。访问字段：用于记录该段被访问的频繁程度；修改位：用于表示该段进入内存后，是否已被修改过；存在位：用于说明该段是否已调入内存；增补位：用于表示该段在运行过程中，是否进行过动态增长；外存始址：用于指示该段在外存中的起始地址。请求调段策略——缺段中断处理在进程执行中访问某段时，若进程所要访问的段未调入内存，便由缺段中断机构产生缺段中断信号，由缺段中断处理程序将所需的段调入内存；若空闲区总和不能满足要求，则可调出一个或几个分段到外存上，再将该段调入内存。地址变换请求分段系统中的地址变换机构，是在分段式存储管理地址变换机构的基础上形成的。 在进程执行期间，由于被访问的段并非全在内存中，所以在地址变换时，若发现所要访问的段不在内存中，必须先将所缺的段调入内存，并修改段表之后，才能再利用段表进行地址转换。为此，在地址变化机构中又增加了某些功能，如缺段中断的请求及处理等。分段共享与保护:在请求分段系统中，用共享段表来记录每一个共享段的段号、段长、内存始址、存在位 等信息，并记录共享此分段的每个进程的情况。4.6.4 请求段页式虚拟存储管理请求段页式虚存管理的动态地址转换机构由段表、页表和快表构成。当前运行进程的段表起始地址已被操作系统置入段表控制寄存器，其动态地址转换过程如下：从逻辑地址出发，先以段号s和页号p作索引去查快表，如果找到，那么立即获得页p的页面号p’，并与位移d一 起拼装得到访问主存的物理地址，从而，完成了地址转换。若查快表失败，就要通过段表和 页表来做地址转换了，用段号s作索引，找到相应表目，由此得到s段的页表的起始地址s’，再以p作索引得到s段p页对应的表目，由此得到页面号p’；这时一方面把s段p页和页面号p’ 置换进快表，另一方面用p和d生成主存的物理地址，从而完成地址转换。上述过程是假设所需信息都在主存的情况下进行的，事实上，许多情况会产生，如查段表时，发现 s 段不在主存，于是产生“缺段中断”，引起操作系统查找 s 段在辅存的位置，并将该段页表调入主存；如查页表时，发现 s 段的 p 页不在主存，于是产生“缺页中断”，引起操作系统查找 s 段 p 页在辅存的位置，并将该页调入主存，当主存已无空闲页框时，就会导致淘汰页面。地址变换4.6.5 局部性原理和抖动问题局部性原理各种内存管理方法在都需要内存和外存之间交换数据。由模拟实验知道：在几乎所有程序的执行中，在一段时间内，CPU总是集中地访问程序中的某一个部分而不是随机地对程序的所有部分具有平均的访问概率。人们把这种现象称为局部性原理(principle of locality)。程序局部性原理（principle of locality）： 在一段时间内，程序的执行仅局限于某个部分；相应地，所访问的存储空间也局限于某个区域内。它描述了一个进程中程序和数据引用的簇聚性倾向。这就使各种管理方式下的虚存实现成为可能。程序局部性原理具体表现为时间局部性和空间局部性。 时间局部性：最近访问过的内存单元可能在不久的将来还要访问。产生时间局部性的典型原因是在程序中存在着大量的循环操作 空间局部性：最近访问过的内存单元附近的存储单元也最有可能被访问。即程序在一段时间内所访问的地址，可能集中在一定的范围内工作集试验表明：任何程序在局部性地放入时，都有一个临界值的要求。当内存分配小于这个临界值时，内存和外存之间的数据交换次数将会急剧增加，出现抖动现象。而内存分配大于这个临界值时，就算再增加内存分配也不能显著减少交换次数。这个内存要求的临界值被称为工作集。工作集 (working set) ：为确保每个进程每一时刻能够执行下去，在内存中必须有的最少页面数。抖动问题当系统给进程分配的内存小于所要求的工作集时，由于内外存之间数据交换非常频繁，大部分时间都花在内存和外存之间的来回调入调出上，造成CPU因等数据空转，使系统性能大大降低，这个现象称为抖动。进程在执行过程中发生抖动的两种可能： 并发进程所要求的工作集大于所分得的内存空间，这时，系统将无法正常工作 存储管理程序为每个并发进程分配了足够的内存空间（大于工作集），但系统无法在开始执行前选择适当的程序段和数据进入内存。这时，只能依靠中断处理程序将所需要的程序和数据调入内存解决抖动问题的办法： 扩大分配的内存空间，使其大于工作集 选择不同的淘汰算法" }, { "title": "游戏设计艺术-游戏通过迭代提高-读书笔记", "url": "/posts/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF-%E6%B8%B8%E6%88%8F%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E6%8F%90%E9%AB%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/", "categories": "游戏, 游戏设计", "tags": "游戏, 游戏设计, 读书笔记", "date": "2022-05-15 00:00:00 +0800", "snippet": "本读书笔记仅记录我本人的体会，肯定不全面，可能不正确。在做出决策之后，你突然意识到自己犯了一个错误怎么办？答案很简单：当你意识到错误是，准备好推翻你之前的决策。## 巴里·伯姆的螺旋模型 想出一个基础的设计 找出设计中最大的风险 建立原型并消除这些风险 测试这个原型 基于你从原型中得出的结论做一个更详细的设计 回到第2步 风险评估与原型设计案例： 游戏：气泡城的囚徒 风险列表 机制不有趣 游戏引擎可能无法同时完成绘制整个城市、所有气泡和秃鹫的任务 可能没有足够的时间完成所有的室内设计和动画角色 不确定人们是否会喜欢角色和剧情 一个关于特技跳伞的电影会在夏季上映，发行商可能要求我们以此作为游戏的主题 风险消除： 游戏机制经常可以用一种更简单的形式分离出来。让程序员制作一个抽象化的核心玩法机制，可能是二维的，用一些简单的几何代替动画角色。可以在一两周内疚得到一个可玩的版本。如果不好玩，就做迭代，直到让它变得好玩为止。 立刻做出一个快速原型，只是单纯在屏幕上展示预估数量的相同物品。如果技术不能达到目标，则需要想出一个解决方案。 让艺术家先创作一间房屋和一位动画角色，评估他需要使用的时间，如果创作周期过长，则需要改变计划。 让艺术家画出一些概念作品或者为你的角色和设定进行一些测试性的渲染。创作一些用于展示剧情发展的故事版。将这些展示给人们，然后评估他们的反应。 要消除这个风险，你可以寄希望于管理层尽快做出决定，或者你可以制作一个能够更容易偏向电影主题的游戏。你甚至可能想出一个制作两个不同游戏的计划——关键在于你要立刻考虑风险并做出行动，保证它不会危及你的项目。 原型设计技巧1：回答一个问题每个原型都应该设计为回答一个或多个问题，如： 我们的技术能够在一个场景中支持多少个动画角色？ 我们的核心玩法有趣吗？这种趣味能够持续较长时间吗？ 我们的角色和设定在艺术上能够融洽地结合在一起吗？ 这个游戏的关卡应该有多大？2：忘记质量尽快构建出能回答问题的原型，别管它有多简陋。3：不要太过留恋4：设定原型的优先级为风险设定优先级，优先为优先级高的风险制作原型。考虑风险的依赖性——如果一个原型的结果可能潜在地让其他原型变得毫无意义，那么它有更高的优先级。5：有效的并行原型同时制作几个原型。6：并不总需要数字化可以为电子游戏创意制作一个简单的桌上游戏原型，我们有时候把这称为“纸上原型”。纸上原型可以快速地开发出来，我们在纸上或者白板上追踪攻击点数，添加或者减少规则，直到游戏看起来很平衡之后才开始尝试编写代码。7：无须交互原型甚至没必要是可交互的。简单的草图和动画能够对回答游戏玩法的问题大有帮助。8：选择一款“快速迭代”的游戏引擎选择“快速迭代”的游戏引擎可以让我们直接从想测试的部分开始测试，而无需每次都操控游戏进行到想要测试的部分。9：先构建玩具10：抓住更多次迭代的机会多少次才足够当处于第一次迭代的开端是，我们不能精确地计算出开发一个高品质游戏所需的时间。马克·赛尔尼 “The Method”：除非你有两个完全完整的关卡，你仍然在进行游戏的基础设计，处于试验品阶段，一旦你到达了这个魔力点，你就处于产品阶段了。这个点通常在化肥30%的必要预算之后。计划性削减预算法则保证出现一些计划之外的事情时，依然能够得到一个可玩的游戏。50%法则所有的核心玩法元素都应该在你规划中的前半部分完成，然后用一半时间让游戏变得更好。如果你计划将所有的系统在50%的时间里完成，那么即使出了问题，依然有时间完成重要的迭代，让游戏变得更好。" }, { "title": "FexCodec-基于JavaFX和哈夫曼算法的解压缩编解码器-学校作业", "url": "/posts/%E5%9F%BA%E4%BA%8Ejavafx%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8-%E5%AD%A6%E6%A0%A1%E4%BD%9C%E4%B8%9A/", "categories": "编程, 工具开发", "tags": "编程, 工具开发, JavaFX, 作业", "date": "2021-12-24 00:00:00 +0800", "snippet": "记录一次学校作业…需求　　使用哈夫曼算法实现对文件的编码解码。基本思路　　我选择使用java作为编程语言，使用javafx作为ui框架。　　将问题拆分成个3个部分：哈夫曼，BitSet操作，UI。　　哈夫曼部分包括了一个哈夫曼树的构建，使用哈夫曼算法编码与解码，哈夫曼树序列化和反序列化。　　BitSet部分是指自己根据要求实现一个二进制序列的数据对象。由于哈夫曼算法最终要把原始数据转换为不定长的二进制序列，最终合并转化为一系列字节写入文件，所以二进制序列的操作是不可避免的。java自带的bitset没有实现两个二进制串连接的操作所以只能自己写一个了。　　UI部分使用javafx。UI中显示编码与解码两个页面，编码、解码需要选择填写原文件位置，和目标文件位置，编码需要额外填写原文件字符集。　　整个程序接口和ui设计的时候留下扩展的余地，以备以后万一想往里加入其它编码方式的编解码。　　我直观地猜测，正确定义了字符集后对应地构建哈夫曼树对于大部分的文件可以得到更好的压缩率。　　初步的界面设计（初步到很丑，后面一定改）：算法描述哈夫曼算法　　哈夫曼算法的意义在于能得到一颗最优二叉树。　　（百度百科）给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。　　构建方法是：把给定的N个叶子节点放入一个集合中，每次取出权值最小的两个节点，合成一个新节点，权值为这两个节点的权值和，放入集合中，多次执行直到集合中只剩一个节点，最优二叉树就构建完成了，最后的节点就是二叉树的根节点。其中节点集合使用小根堆来维护，小根堆的特点是堆顶元素总是最小的，单次放入取出元素的时间复杂度都为O(logn)，因为构建哈夫曼树得到的节点总数为2倍叶子节点的数量减1，对集合操作的次数和叶子节点的个数成正比，所以最终时间复杂度为O(nlogn)。　　最优二叉树可以用于优化基于判断的查找以及数据压缩。　　伪代码表示：turn leaves to nodesloop if nodes.count &amp;gt; 1 node_a = nodes.FindAndRemoveBiggest() node_b = nodes.FindAndRemoveBiggest() node_c.leftNode = node_a node_c.rightNode = node_b node_c.frequency = node_a.frequency + node_a.frequencyend loopBitSet的实现　　BitSet的UML图如下：　　在BitSet中，使用long类型的数组来保存二进制序列，用一个long变量表示有效长度，二进制序列的位索引从word[0]的最低位开始计起。　　append函数的作用是把一个二进制序列附加到一个二进制序列的前面，参数可以是一个二进制序列也可以是一个long值和一个int值表示有效长度。前者实际上是把要加的二进制序列拆分成若干个long类型的值然后调用后者。　　appendlong的步骤是：1.对储存数组第一个未填满的位置，使用掩码把超过了validLength（有效长度）处于高位的无效位进行过滤，过滤为0，放置高位上的无效位存在为1的位污染后面的运算。将1左移(validLength % 64)位再减1得到掩码。如：有效位有75位储存的words[1]为0000000000000000000000000000000001000000000000000001001110101010 0000000000000000000000000000000001000000000000000001001110101010&amp;amp; 0000000000000000000000000000000001000000000000000000011111111111= 00000000000000000000000000000000010000000000000000000011101010102.将要附加的long值左移(64 - length)位，再右移(64 - length)位，将输入的二进制序列的无效位过滤。3.将输入的long值左移(validLength % 64)，和数组第一个未填满的位置进行位或运算，并储存到数组里。4.判断要储存输入的二进制序列是否需要数组的下一个位置：将原本的有效位长度和要添加的有效位长度相加，除以八，和原本的有效位长度除以8比较（两个都是向下取整），如果前者大则表示需要后面的位置储存。5.如果4为真则把数组的下一位置设置为0并赋值为输入的long值右移(64 - (validLength % 64))位。6.有效长度加上增加的长度。伪代码：ensureCapacity((int) (validLength + length-1 &amp;gt;&amp;gt;&amp;gt; 6)+1);words[(int) (validLength &amp;gt;&amp;gt;&amp;gt; 6)] &amp;amp;= (1l &amp;lt;&amp;lt; validLength % 64) - 1l;value = value &amp;lt;&amp;lt; (64 - length) &amp;gt;&amp;gt;&amp;gt; (64 - length);words[(int) (validLength &amp;gt;&amp;gt;&amp;gt; 6)] |= value &amp;lt;&amp;lt; validLength % 64;//如果添加的数据不止影响在words的同一个位置if (!(validLength + length - 1 &amp;gt;&amp;gt;&amp;gt; 6 == validLength - 1 &amp;gt;&amp;gt;&amp;gt; 6 || validLength % 64 == 0)) { words[(int) (validLength &amp;gt;&amp;gt;&amp;gt; 6) + 1] = 0; words[(int) (validLength &amp;gt;&amp;gt;&amp;gt; 6) + 1] |= value &amp;gt;&amp;gt;&amp;gt; (64 - (validLength % 64));}validLength += length;一些实现细节生成映射　　哈夫曼树构建出来后，我不直接用树来进行编码与解码，而是使用深搜遍历哈夫曼树的所有叶节点，将整棵树转化为字符和二进制序列的映射（即编码），由两个哈希表组成。　　具体细节是：声明一个临时的二进制序列bitset，使用深度优先搜索，当往左子树遍历时，给bitset末尾附加1；往左子树遍历时，给bitset末尾附加0；回溯时则将有效长度减少1位。这样这个二进制序列能随时地表示当前节点的二进制序列。当遍历到一个叶节点时就将该叶节点表示的字符和bitset的复制结果存入两个哈希表。　　构建映射的时间复杂度为O(n)，n为节点数量，编码解码的时间复杂度都是O(n)，n为要编码、解码的字符串、二进制序列的长度，解码与使用树解码相同。二进制文件设计　　编码后的二进制文件结构分为三个部分：原文件编码格式，哈夫曼树，编码后的二进制序列。原文件编码格式　　直接储存字符集的名字来表示原文件编码格式。先是一个4字节的整数，表示名字的长度；然后就是名字的字符串（以Unicode的编码储存）。如果没有字符集则原本表示名字长度的位置写入0.哈夫曼树　　首先写入树里字符的种类数量，使用一个4字节的整数储存；然后遍历字符到二进制序列的哈希表中的元素，每次遍历先写入字符，（是否是文字字符由上一步来确定。如果是文字字符，这里的字符会被转为char字符然后用Unicode格式储存，占用两个字节；如果是字节，则占用一个字节），然后写入二进制编码的有效长度，最后写入字符对应的二进制序列，字节长度为可以表示有效长度的最小长度。日志文件　　我希望在编码与译码的时候可以生成一份明文报告，包括是否成功、各个操作耗时、哈夫曼树的具体形态等信息。　　我用了比较简陋的实现方法：在编译码的接口上加一个OutputStreamWriter的参数，在编译码的类里添加一个void log(String)方法，如果我想把报告输出为文件，就给一个FileOutPutStream，如果我只想输出到控制台，就把System.out传进去，如果我不想输出，就不传参数进去，在log方法里跳过。对字节和文本字符统一处理　　由于编码的时候要处理把字节看做哈夫曼树的一个叶子和把文本字符看做一个叶子两种情况，所以考虑将两者抽象为一个东西，编解码的时候可以统一处理。我把抽象出来的东西命名为Cell，意思是构建哈夫曼树的基本字符。　　Cell的设计如下：　　value的getter setter没什么好说的，hashCode和equal都是为了他们可以在hashmap中正常工作，getByteArray是因为译码的时候需要知道他们的字节表示。　　光有个Cell还不行，还要有个CellReader，它的子类实现有ByteReader，CharReader，TxtReader，他们有不同的构造函数，参数是不同类型的输入流，在读取的时候使用这三种Reader来获得对应种类的Cell。　　用于读取字符的有两个类：CharReader和TxtReader。区别在于CharReader使用InputStream进行构造，在GetNext方法中读取两个字节然后组合成char值，只能读取Unicode字符；TxtReader使用InputStreamReader进行构造，InputStreamReader可以在流中进行编码转换，能读取所有字符。有CharReader的原因是TxtReader有些情况不能用，InputStreamReader会对读取的输入流缓存（而且没法取消），在编码的时候没什么问题，但是在反序列化哈夫曼树的时候，字符和数字交叉写在文件中，读取数字需要用字节流读取，读取字符要用CellReader读取，也就是说多个转换流共用一个输入流，如果InputStreamReader缓存了，输入流读到后面去了，其他转换流就会出问题。于是在编码的过程中使用TxtReader，在解码的过程中使用CharReader。编码的结果如果要存字符，一定使用Unicode编码，因为java中字符变量本身就是Unicode编码储存的，使用Unicode字符集读取与写入都只需要几次位运算就可以得到期望的结果。具体实现两个编码器解码器接口的定义：编码器：package fexla.codec;import java.io.IOException;import java.io.InputStream;public interface Coder { byte[] Encode(InputStream is, String[] args) throws IOException;}解码器：package fexla.codec;import java.io.IOException;import java.io.InputStream;import java.io.OutputStreamWriter;public interface Decoder { byte[] decode(InputStream is) throws IOException;}Cell：package fexla.codec.haffuman.cell;/** * 表示最小的编解码的单位， * 比如在文本文件中，一个字就是一个Code * 在二进制文件中，一个字节就是一个Code */public abstract class Cell&amp;lt;T&amp;gt; { public abstract T getValue(); public abstract void setValue(T value); public abstract int hashCode(); public abstract byte[] getByteArray(); @Override public abstract boolean equals(Object obj) ;}package fexla.codec.haffuman.cell;public class ByteCell extends Cell&amp;lt;Byte&amp;gt; { private byte value; public Byte getValue() { return value; } public void setValue(Byte value) { this.value = value; } public ByteCell(byte value) { this.value = value; } @Override public int hashCode() { return value; } @Override public byte[] getByteArray() { return new byte[]{value}; } @Override public boolean equals(Object obj) { if (obj instanceof ByteCell) return value == ((ByteCell) obj).getValue(); return false; }}package fexla.codec.haffuman.cell;import java.io.CharArrayWriter;import java.io.DataOutputStream;import java.nio.charset.Charset;public class TxtCell extends Cell&amp;lt;Character&amp;gt; { private char value; public Character getValue() { return value; } public void setValue(Character value) { this.value = value; } @Override public int hashCode() { return 0; } @Override public byte[] getByteArray() { byte[] b = new byte[2]; b[0] = (byte) ((value &amp;gt;&amp;gt;&amp;gt; 8) &amp;amp; 0xFF); b[1] = (byte) ((value &amp;gt;&amp;gt;&amp;gt; 0) &amp;amp; 0xFF); return b; } public TxtCell(char value) { this.value = value; } @Override public boolean equals(Object obj) { if (obj instanceof TxtCell) return value == ((TxtCell) obj).getValue(); return false; } @Override public String toString() { return String.valueOf(value); }}package fexla.codec.haffuman.cell.reader;import fexla.codec.haffuman.cell.Cell;import java.io.IOException;public abstract class CellReader&amp;lt;T extends Cell&amp;gt; { public abstract T GetNext() throws IOException; public abstract void setSource(Object source);}package fexla.codec.haffuman.cell.reader;import fexla.codec.haffuman.cell.ByteCell;import java.io.IOException;import java.io.InputStream;public class ByteReader extends CellReader&amp;lt;ByteCell&amp;gt; { private InputStream reader; public ByteReader(InputStream inputStream) { reader = inputStream; } @Override public ByteCell GetNext() throws IOException { int c = reader.read(); if (c == -1) return null; return new ByteCell((byte) c); } @Override public void setSource(Object source) { if (source instanceof InputStream) { reader = (InputStream) source; } }}package fexla.codec.haffuman.cell.reader;import fexla.codec.haffuman.cell.TxtCell;import java.io.IOException;import java.io.InputStream;public class CharReader extends CellReader&amp;lt;TxtCell&amp;gt; { private InputStream reader; public CharReader(InputStream inputStream) { reader = inputStream; } @Override public TxtCell GetNext() throws IOException { byte a = (byte) reader.read(), b = (byte) reader.read(); char c = (char) (((a &amp;amp; 0xFF) &amp;lt;&amp;lt; 8) | (b &amp;amp; 0xFF)); return new TxtCell(c); } @Override public void setSource(Object source) { if (source instanceof InputStream) { reader = (InputStream) source; } }}package fexla.codec.haffuman.cell.reader;import fexla.codec.haffuman.cell.TxtCell;import java.io.*;public class TxtReader extends CellReader&amp;lt;TxtCell&amp;gt; { private InputStreamReader reader; public TxtReader(InputStreamReader inputStream) { reader = inputStream; } @Override public TxtCell GetNext() throws IOException { int value = reader.read(); if (value == -1) return null; return new TxtCell((char) value); } @Override public void setSource(Object source) { if (source instanceof InputStreamReader) { reader = (InputStreamReader) source; } }}数据结构的实现：小根堆：package fexla.codec.util;import java.util.ArrayList;import java.util.List;/// &amp;lt;summary&amp;gt;/// 小根堆/// compare反过来就是大根堆/// &amp;lt;/summary&amp;gt;/// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;堆内元素的类型&amp;lt;/typeparam&amp;gt;public class Heap&amp;lt;T extends Comparable&amp;gt; { //堆内元素 List&amp;lt;T&amp;gt; num; public Heap() { this.num = new ArrayList&amp;lt;&amp;gt;(); } //自下而上更新堆 private void Update(int ind) { if (ind &amp;lt;= 0) return; if (num.get(ind).compareTo(num.get(ind / 2)) &amp;lt; 0) { Swap(ind, ind / 2); Update(ind / 2); } } //num.get().compareTo(num.get()) //自上而下更新堆 private void UpdateDown(int ind) { if (ind &amp;lt; 0 || ind * 2 + 1 &amp;gt;= num.size()) return; int n; if (ind * 2 + 2 &amp;gt;= num.size()) { n = ind * 2 + 1; } else { n = num.get(ind * 2 + 1).compareTo(num.get(ind * 2 + 2)) &amp;lt; 0 ? ind * 2 + 1 : ind * 2 + 2; } if (num.get(ind).compareTo(num.get(n)) &amp;gt; 0) { Swap(ind, n); UpdateDown(n); } } private void Swap(int ind1, int ind2) { T temp = num.get(ind1); num.set(ind1, num.get(ind2)); num.set(ind2, temp); } //把一个元素压入堆中 public void PushBack(T value) { num.add(value); Update(num.size() - 1); } public T Get(int ind) { if (ind &amp;gt;= num.size()) return null; return num.get(ind); } public T Top() { return num.get(0); } //取出堆顶元素 public void Pop() { if (num.size() != 0) num.set(0, num.get(num.size() - 1)); num.remove(num.size() - 1); UpdateDown(0); } //返回堆内元素的数量 public int size() { return num.size(); } public boolean isEmpty() { return num.isEmpty(); }}​ 二进制序列：package fexla.codec.util;import java.math.BigInteger;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.util.Arrays;import java.util.Objects;public class BitSet { public long[] words; private long validLength; public static final BitSet ONE = new BitSet(new long[]{1}, 1); public static final BitSet ZERO = new BitSet(new long[]{0}, 1); public BitSet(long[] words, long validLength) { this.words = words; this.validLength = validLength; } public BitSet(long validLength) { words = new long[(int) ((validLength - 1 &amp;gt;&amp;gt;&amp;gt; 6) + 1)]; } public BitSet() { words = new long[]{0, 0}; validLength = 0; } public void append(BitSet set) { long[] appendWords = set.words; for (int i = 0; i &amp;lt; set.validLength &amp;gt;&amp;gt;&amp;gt; 6; i++) { appendLong(appendWords[i], 64); } appendLong(appendWords[(int) (set.validLength &amp;gt;&amp;gt;&amp;gt; 6)], (int) (set.validLength % 64)); } public void appendLong(long value, int length) { ensureCapacity((int) (validLength + length-1 &amp;gt;&amp;gt;&amp;gt; 6)+1); words[(int) (validLength &amp;gt;&amp;gt;&amp;gt; 6)] &amp;amp;= (1l &amp;lt;&amp;lt; validLength % 64) - 1l; value = value &amp;lt;&amp;lt; (64 - length) &amp;gt;&amp;gt;&amp;gt; (64 - length); words[(int) (validLength &amp;gt;&amp;gt;&amp;gt; 6)] |= value &amp;lt;&amp;lt; validLength % 64; //如果添加的数据不止影响在word的同一个位置 if (!(validLength + length - 1 &amp;gt;&amp;gt;&amp;gt; 6 == validLength - 1 &amp;gt;&amp;gt;&amp;gt; 6 || validLength % 64 == 0)) { words[(int) (validLength &amp;gt;&amp;gt;&amp;gt; 6) + 1] = 0; words[(int) (validLength &amp;gt;&amp;gt;&amp;gt; 6) + 1] |= value &amp;gt;&amp;gt;&amp;gt; (64 - (validLength % 64)); } validLength += length; } private void ensureCapacity(int wordsRequired) { if (words.length &amp;lt; wordsRequired) { // 分配空间 int request = Math.max(2 * words.length, wordsRequired); words = Arrays.copyOf(words, request); } } public int bitAt(long index) { return (int) ((words[(int) (index &amp;gt;&amp;gt;&amp;gt; 6)] &amp;amp; (1l &amp;lt;&amp;lt; index % 64)) &amp;gt;&amp;gt;&amp;gt; index % 64); } public void bitSet(long index, int value) { if (value == 0) { words[(int) (index &amp;gt;&amp;gt;&amp;gt; 6)] &amp;amp;= (-1l - (1 &amp;lt;&amp;lt; (index % 64))); } else { words[(int) (index &amp;gt;&amp;gt;&amp;gt; 6)] |= 1l &amp;lt;&amp;lt; (index % 64); } } @Override public String toString() { StringBuilder str = new StringBuilder(); for (long i = validLength - 1; i &amp;gt;= 0; i--) { str.append(bitAt(i)); } return str.toString(); } @Override public BitSet clone() { long[] cloneWords = Arrays.copyOf(words, (int) (validLength &amp;gt;&amp;gt;&amp;gt; 6) + 1); return new BitSet(cloneWords, validLength); } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; BitSet bitSet = (BitSet) o; if (bitSet.validLength != validLength) return false; for (int i = 0; i &amp;lt; validLength &amp;gt;&amp;gt;&amp;gt; 6; i++) { if (bitSet.words[i] != words[i]) return false; } if (validLength % 64 == 0) return true; long lasta = (words[(int) (validLength &amp;gt;&amp;gt;&amp;gt; 6)] &amp;lt;&amp;lt; (64 - validLength % 64)) &amp;gt;&amp;gt;&amp;gt; (64 - validLength % 64); long lastb = (bitSet.words[(int) (validLength &amp;gt;&amp;gt;&amp;gt; 6)] &amp;lt;&amp;lt; (64 - validLength % 64)) &amp;gt;&amp;gt;&amp;gt; (64 - validLength % 64); return lasta == lastb; } @Override public int hashCode() { long h = &quot;fexla&quot;.hashCode(); for (int i = (int) (validLength &amp;gt;&amp;gt;&amp;gt; 6); --i &amp;gt;= 0; ) h ^= words[i] * (i + 1); long last = (words[(int) (validLength &amp;gt;&amp;gt;&amp;gt; 6)] &amp;lt;&amp;lt; (64 - validLength % 64)) &amp;gt;&amp;gt;&amp;gt; (64 - validLength % 64); h ^= last * ((validLength &amp;gt;&amp;gt;&amp;gt; 6) + 1); return (int) ((h &amp;gt;&amp;gt; 32) ^ h) ^ Long.hashCode(validLength); } public void narrow(long size) { validLength -= size; validLength = validLength &amp;gt; 0 ? validLength : 0; //清除原位置的值 for (int i = 0; i &amp;lt; size &amp;gt;&amp;gt; 3; i++) { appendLong(0l, 64); } appendLong(0l, (int) (size % 64)); validLength -= size; validLength = validLength &amp;gt; 0 ? validLength : 0; } /** * 将储存的二进制序列转为byte数组 * * @return byte数组 */ public byte[] toByteArray() { if (validLength == 0) return new byte[0]; int len = (int) ((validLength - 1) &amp;gt;&amp;gt;&amp;gt; 3) + 1; byte[] bytes = new byte[len]; for (int i = 0; i &amp;lt; len; i++) { bytes[i] = (byte) (words[i &amp;gt;&amp;gt;&amp;gt; 3] &amp;gt;&amp;gt;&amp;gt; (8 * (i % 8))); } return bytes; } public static BitSet valueOf(byte[] bytes) { return valueOf(bytes, bytes.length * 8); } public static BitSet valueOf(byte[] bytes, int validLength) { if (validLength == 0) return new BitSet(); long words[] = new long[(int) ((validLength - 1 &amp;gt;&amp;gt;&amp;gt; 6) + 1)]; int byteLen = ((validLength - 1) &amp;gt;&amp;gt;&amp;gt; 3) + 1; for (int i = 0; i &amp;lt; byteLen; i++) { words[i &amp;gt;&amp;gt;&amp;gt; 3] |= (bytes[i] &amp;amp; 0xffl) &amp;lt;&amp;lt; 8 * (i % 8); } return new BitSet(words, validLength); } private static final BigInteger bitSignificance = BigInteger.TWO.pow(64);//2^64,表示一个long位的权值 private static final BigInteger signSignificance = BigInteger.TWO.pow(63);//2^63,表示一个long原本表示符号的位代表的值 /** * 二进制序列转BigInteger * * @return */ public BigInteger toBigInteger() { BigInteger result = BigInteger.ZERO; int length = (int) (validLength - 1 &amp;gt;&amp;gt;&amp;gt; 6) + 1; for (int i = length - 1; i &amp;gt;= 0; i--) { long value = words[i]; if (value &amp;gt;= 0) result = result.multiply(bitSignificance).add(BigInteger.valueOf(value)); else result = result.multiply(bitSignificance).add(BigInteger.valueOf(value &amp;amp; Long.MAX_VALUE)).add(signSignificance); } return result; } public void clear() { words = new long[words.length]; validLength = 0; } public long getValidLength() { return validLength; }}哈夫曼编解码器类：package fexla.codec.haffuman;import fexla.codec.Coder;import fexla.codec.Decoder;import fexla.codec.haffuman.cell.Cell;import fexla.codec.haffuman.cell.reader.ByteReader;import fexla.codec.haffuman.cell.reader.CellReader;import fexla.codec.haffuman.cell.reader.CharReader;import fexla.codec.haffuman.cell.reader.TxtReader;import java.io.*;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import java.nio.charset.UnsupportedCharsetException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class Haffuman implements Coder, Decoder { private OutputStreamWriter logger; public Haffuman(OutputStreamWriter logger) { this.logger = logger; } @Override public byte[] Encode(InputStream is, String[] args) throws IOException { long startms = System.currentTimeMillis(); CellReader cellReader = new ByteReader(is); Charset charset = null; //如果有设定编码，把cellReader赋值为一个特定编码集的TxtCellReader if (args != null &amp;amp;&amp;amp; args.length != 0 &amp;amp;&amp;amp; !args[0].equals(&quot;&quot;) &amp;amp;&amp;amp; !args[0].equals(&quot;ANSI&quot;)) { try { charset = Charset.forName(args[0]); log(&quot;编码集为： &quot; + charset.name() + &quot;\\n&quot;); } catch (UnsupportedCharsetException e) { logger.write(&quot;不支持的编码集\\n&quot;); } cellReader = new TxtReader(new InputStreamReader(is, charset)); } //读入的同时统计每个Cell出现的频率频率 Cell b; List&amp;lt;Cell&amp;gt; cells = new ArrayList&amp;lt;&amp;gt;(); Map&amp;lt;Cell, Integer&amp;gt; freq = new HashMap&amp;lt;&amp;gt;(); while ((b = cellReader.GetNext()) != null) { cells.add(b); freq.compute(b, (key, value) -&amp;gt; value == null ? 1 : value + 1); } log(&quot;\\n字符频率表：\\n&quot;); int loop = 0; for (Map.Entry&amp;lt;Cell, Integer&amp;gt; entry : freq.entrySet()) { Cell cell = entry.getKey(); Integer fre = entry.getValue(); log(cell.getValue() + &quot; &quot; + fre + &quot;\\t\\t&quot;); if (++loop % 6 == 0) log(&quot;\\n&quot;); } long treeStartms = System.currentTimeMillis(); HaffumanTree tree = new HaffumanTree(freq); log(&quot;\\n构建哈夫曼树耗时： &quot; + (System.currentTimeMillis() - treeStartms) + &quot;ms\\n&quot;); ByteArrayOutputStream baos = new ByteArrayOutputStream(); if (charset != null) {//写入源文件的编码集名字 new DataOutputStream(baos).writeInt(charset.name().length()); baos.write(charset.name().getBytes(StandardCharsets.UTF_16BE)); } else { new DataOutputStream(baos).writeInt(0); } long encodeStartms = System.currentTimeMillis(); tree.serialize(baos);//将哈夫曼树序列化并写入 baos.write(tree.encode(cells).toByteArray());//写入编码得到的byte数组 log(&quot;\\n编码耗时： &quot; + (System.currentTimeMillis() - encodeStartms) + &quot;ms\\n&quot;); baos.flush(); baos.close(); byte[] result = baos.toByteArray(); log(&quot;\\n总耗时： &quot; + (System.currentTimeMillis() - startms) + &quot;ms\\n&quot;); return result; } @Override public byte[] decode(InputStream is) throws IOException { CellReader cellReader = new ByteReader(is); DataInputStream dataInputStream = new DataInputStream(is); int charsetNameLen = dataInputStream.readInt();//读取字符集名字的长度 Charset charset = null; if (charsetNameLen != 0) {//读取字符集 StringBuilder charsetName = new StringBuilder(); for (int i = 0; i &amp;lt; charsetNameLen; i++) { charsetName.append(dataInputStream.readChar()); } log(&quot;charset = &quot; + charsetName); charset = Charset.forName(charsetName.toString()); cellReader = new CharReader(is); } HaffumanTree tree = HaffumanTree.deSerialize(is, cellReader);//解码出哈夫曼树 List&amp;lt;Cell&amp;gt; result = tree.decode(is); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ByteArrayOutputStream data = new ByteArrayOutputStream(); for (Cell cell : result) { data.write(cell.getByteArray()); }// new OutputStreamWriter(baos).write(charset.encode(CharBuffer.wrap(data.toByteArray()))); if (charset == null) baos.write(data.toByteArray()); else { baos.write(data.toString(StandardCharsets.UTF_16BE).getBytes(charset)); } baos.flush(); baos.close(); data.flush(); data.close(); return baos.toByteArray(); } private void log(String string) { if (logger != null) { try { logger.write(string); } catch (IOException e) { } } }}哈夫曼树：package fexla.codec.haffuman;import fexla.codec.haffuman.cell.Cell;import fexla.codec.haffuman.cell.reader.CellReader;import fexla.codec.util.BitSet;import fexla.codec.util.Heap;import java.io.*;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class HaffumanTree { private Map&amp;lt;Cell, BitSet&amp;gt; cell2Bit; private Map&amp;lt;BitSet, Cell&amp;gt; Bit2cell; private int height;//哈夫曼树的高度 public HaffumanTree(Map&amp;lt;Cell, Integer&amp;gt; freq) { cell2Bit = new HashMap&amp;lt;&amp;gt;(); Bit2cell = new HashMap&amp;lt;&amp;gt;(); Heap&amp;lt;Node&amp;gt; heap = new Heap&amp;lt;&amp;gt;(); freq.forEach((k, v) -&amp;gt; heap.PushBack(new Node(k, v)));//所有字符都压入小根堆 while (heap.size() &amp;gt; 1) { Node a, b, parent; a = heap.Top(); heap.Pop(); b = heap.Top(); heap.Pop(); parent = new Node(a, b); heap.PushBack(parent); } Node root = heap.Top(); height = root.height; search(root, new BitSet()); } private HaffumanTree() { cell2Bit = new HashMap&amp;lt;&amp;gt;(); Bit2cell = new HashMap&amp;lt;&amp;gt;(); } /** * 编码 * * @param cells * @return */ public BitSet encode(List&amp;lt;Cell&amp;gt; cells) { BitSet bitSet = new BitSet(); for (int i = 0; i &amp;lt; cells.size(); i++) { bitSet.append(cell2Bit.get(cells.get(i))); } BitSet length=new BitSet(); long validLength= bitSet.getValidLength(); validLength=Long.reverseBytes(validLength); length.appendLong(validLength,64); length.append(bitSet); bitSet=length; return bitSet; } /** * 解码 * * @param is 输入流 * @return 解码出来的内容 * @throws IOException */ public List&amp;lt;Cell&amp;gt; decode(InputStream is) throws IOException { BitSet bitSet = new BitSet(); long length = new DataInputStream(is).readLong(); for (int i = 0; i &amp;lt; (length-1&amp;gt;&amp;gt;&amp;gt;3)+1; i++) { bitSet.appendLong((byte)is.read(), 8); } BitSet tempSet = new BitSet(); List&amp;lt;Cell&amp;gt; cells = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; length; i++) { tempSet.appendLong(bitSet.bitAt(i), 1); Bit2cell.compute(tempSet, (k, v) -&amp;gt; { if (v != null) { tempSet.clear(); cells.add(v); } return v; }); if (tempSet.getValidLength() &amp;gt; height) { tempSet.clear(); } } return cells; } /** * 递归深搜遍历所有节点，得到字符和编码后二进制的映射 * * @param node * @param bitSet */ private void search(Node node, BitSet bitSet) { if (node.cell != null) { cell2Bit.put(node.cell, bitSet.clone()); Bit2cell.put(bitSet.clone(), node.cell); return; } if (node.left != null) { bitSet.append(BitSet.ONE); search(node.left, bitSet); bitSet.narrow(1); } if (node.right != null) { bitSet.append(BitSet.ZERO); search(node.right, bitSet); bitSet.narrow(1); } } /** * 将哈夫曼树序列化 * * @return 字节数组 */ public byte[] serialize() throws IOException { ByteArrayOutputStream stream = new ByteArrayOutputStream(); serialize(stream); return stream.toByteArray(); } /** * 将哈夫曼树序列化，并输出到流中 */ public void serialize(OutputStream stream) throws IOException { DataOutputStream dataOutputStream = new DataOutputStream(stream); dataOutputStream.writeInt(cell2Bit.size()); cell2Bit.forEach((k, v) -&amp;gt; { try { byte[] byteArray = k.getByteArray(); dataOutputStream.write(byteArray); int validLength = (int) v.getValidLength(); dataOutputStream.writeInt(validLength); dataOutputStream.write(v.toByteArray()); } catch (IOException e) { e.printStackTrace(); } }); } public static HaffumanTree deSerialize(InputStream stream, CellReader cellReader) throws IOException { HaffumanTree haffumanTree = new HaffumanTree(); DataInputStream dataInputStream = new DataInputStream(stream); int size = dataInputStream.readInt(); Map&amp;lt;Cell, BitSet&amp;gt; cell2Bit = haffumanTree.cell2Bit; Map&amp;lt;BitSet, Cell&amp;gt; Bit2cell = haffumanTree.Bit2cell; int height = 0; for (int i = 0; i &amp;lt; size; i++) { Cell cell = cellReader.GetNext(); int validLength = dataInputStream.readInt(); height = Math.max(height, validLength); byte[] bitsetByteArray = stream.readNBytes(((validLength - 1) &amp;gt;&amp;gt;&amp;gt; 3) + 1); BitSet bitSet = BitSet.valueOf(bitsetByteArray, validLength); cell2Bit.put(cell, bitSet.clone()); Bit2cell.put(bitSet.clone(), cell); } haffumanTree.height = height; return haffumanTree; } public Map&amp;lt;Cell, BitSet&amp;gt; getCell2Bit() { return cell2Bit; } public void setCell2Bit(Map&amp;lt;Cell, BitSet&amp;gt; cell2Bit) { this.cell2Bit = cell2Bit; } public Map&amp;lt;BitSet, Cell&amp;gt; getBit2cell() { return Bit2cell; } public void setBit2cell(Map&amp;lt;BitSet, Cell&amp;gt; bit2cell) { Bit2cell = bit2cell; } public BitSet get(Cell key) { return cell2Bit.get(key); } @Override public String toString() { StringBuilder str = new StringBuilder(); str.append(cell2Bit.size()); str.append(&#39;\\n&#39;); cell2Bit.forEach((k, v) -&amp;gt; { if (k != null) str.append(k.getValue()). append(&quot;\\t&quot;). append(v).append(&quot;\\n&quot;); }); return str.toString(); } class Node implements Comparable&amp;lt;Node&amp;gt; { public Cell cell; public int freq; public int height;//这个节点被创建时从子孙节点往上数的高度,用于统计整棵树的高度 public Node left, right, parent; public Node(Cell cell, int freq) { this.cell = cell; this.freq = freq; } public Node(Node left, Node right) { this.left = left; this.right = right; left.parent = this; right.parent = this; freq = left.freq + right.freq; height = left.height &amp;gt; right.height ? left.height + 1 : right.height + 1; } @Override public int compareTo(Node o) { return freq - o.freq; } }}哈夫曼编码解码器：package fexla.codec.haffuman;import fexla.codec.Coder;import fexla.codec.Decoder;import fexla.codec.haffuman.cell.Cell;import fexla.codec.haffuman.cell.reader.ByteReader;import fexla.codec.haffuman.cell.reader.CellReader;import fexla.codec.haffuman.cell.reader.CharReader;import fexla.codec.haffuman.cell.reader.TxtReader;import java.io.*;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import java.nio.charset.UnsupportedCharsetException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class Haffuman implements Coder, Decoder { private OutputStreamWriter logger; public Haffuman(OutputStreamWriter logger) { this.logger = logger; } @Override public byte[] Encode(InputStream is, String[] args) throws IOException { long startms = System.currentTimeMillis(); CellReader cellReader = new ByteReader(is); Charset charset = null; //如果有设定编码，把cellReader赋值为一个特定编码集的TxtCellReader if (args != null &amp;amp;&amp;amp; args.length != 0 &amp;amp;&amp;amp; !args[0].equals(&quot;&quot;) &amp;amp;&amp;amp; !args[0].equals(&quot;ANSI&quot;)) { try { charset = Charset.forName(args[0]); log(&quot;编码集为： &quot; + charset.name() + &quot;\\n&quot;); } catch (UnsupportedCharsetException e) { logger.write(&quot;不支持的编码集\\n&quot;); } cellReader = new TxtReader(new InputStreamReader(is, charset)); } //读入的同时统计每个Cell出现的频率频率 Cell b; List&amp;lt;Cell&amp;gt; cells = new ArrayList&amp;lt;&amp;gt;(); Map&amp;lt;Cell, Integer&amp;gt; freq = new HashMap&amp;lt;&amp;gt;(); while ((b = cellReader.GetNext()) != null) { cells.add(b); freq.compute(b, (key, value) -&amp;gt; value == null ? 1 : value + 1); } log(&quot;\\n字符频率表：\\n&quot;); int loop = 0; for (Map.Entry&amp;lt;Cell, Integer&amp;gt; entry : freq.entrySet()) { Cell cell = entry.getKey(); Integer fre = entry.getValue(); log(cell.getValue() + &quot; &quot; + fre + &quot;\\t\\t&quot;); if (++loop % 6 == 0) log(&quot;\\n&quot;); } long treeStartms = System.currentTimeMillis(); HaffumanTree tree = new HaffumanTree(freq); log(&quot;\\n构建哈夫曼树耗时： &quot; + (System.currentTimeMillis() - treeStartms) + &quot;ms\\n&quot;); ByteArrayOutputStream baos = new ByteArrayOutputStream(); if (charset != null) {//写入源文件的编码集名字 new DataOutputStream(baos).writeInt(charset.name().length()); baos.write(charset.name().getBytes(StandardCharsets.UTF_16BE)); } else { new DataOutputStream(baos).writeInt(0); } long encodeStartms = System.currentTimeMillis(); tree.serialize(baos);//将哈夫曼树序列化并写入 baos.write(tree.encode(cells).toByteArray());//写入编码得到的byte数组 log(&quot;\\n编码耗时： &quot; + (System.currentTimeMillis() - encodeStartms) + &quot;ms\\n&quot;); baos.flush(); baos.close(); byte[] result = baos.toByteArray(); log(&quot;\\n总耗时： &quot; + (System.currentTimeMillis() - startms) + &quot;ms\\n&quot;); return result; } @Override public byte[] decode(InputStream is) throws IOException { CellReader cellReader = new ByteReader(is); DataInputStream dataInputStream = new DataInputStream(is); int charsetNameLen = dataInputStream.readInt();//读取字符集名字的长度 Charset charset = null; if (charsetNameLen != 0) {//读取字符集 StringBuilder charsetName = new StringBuilder(); for (int i = 0; i &amp;lt; charsetNameLen; i++) { charsetName.append(dataInputStream.readChar()); } log(&quot;charset = &quot; + charsetName); charset = Charset.forName(charsetName.toString()); cellReader = new CharReader(is); } HaffumanTree tree = HaffumanTree.deSerialize(is, cellReader);//解码出哈夫曼树 List&amp;lt;Cell&amp;gt; result = tree.decode(is); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ByteArrayOutputStream data = new ByteArrayOutputStream(); for (Cell cell : result) { data.write(cell.getByteArray()); } if (charset == null) baos.write(data.toByteArray()); else { baos.write(data.toString(StandardCharsets.UTF_16BE).getBytes(charset)); } baos.flush(); baos.close(); data.flush(); data.close(); return baos.toByteArray(); } private void log(String string) { if (logger != null) { try { logger.write(string); } catch (IOException e) { } } }}UI：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;?import javafx.geometry.*?&amp;gt;&amp;lt;?import javafx.scene.control.*?&amp;gt;&amp;lt;?import javafx.scene.layout.*?&amp;gt;&amp;lt;AnchorPane minHeight=&quot;400.0&quot; minWidth=&quot;600.0&quot; xmlns=&quot;http://javafx.com/javafx/8&quot; xmlns:fx=&quot;http://javafx.com/fxml/1&quot; fx:controller=&quot;fexla.codec.view.Controller&quot;&amp;gt; &amp;lt;children&amp;gt; &amp;lt;TabPane layoutX=&quot;6.0&quot; layoutY=&quot;29.0&quot; prefHeight=&quot;400.0&quot; prefWidth=&quot;600.0&quot; tabClosingPolicy=&quot;UNAVAILABLE&quot; AnchorPane.bottomAnchor=&quot;0.0&quot; AnchorPane.leftAnchor=&quot;0.0&quot; AnchorPane.rightAnchor=&quot;0.0&quot; AnchorPane.topAnchor=&quot;0.0&quot;&amp;gt; &amp;lt;tabs&amp;gt; &amp;lt;Tab text=&quot;哈夫曼编码&quot;&amp;gt; &amp;lt;content&amp;gt; &amp;lt;AnchorPane minHeight=&quot;0.0&quot; minWidth=&quot;0.0&quot; prefHeight=&quot;180.0&quot; prefWidth=&quot;200.0&quot;&amp;gt; &amp;lt;children&amp;gt; &amp;lt;VBox alignment=&quot;TOP_CENTER&quot; prefHeight=&quot;342.0&quot; prefWidth=&quot;600.0&quot; spacing=&quot;20.0&quot; AnchorPane.bottomAnchor=&quot;0.0&quot; AnchorPane.leftAnchor=&quot;0.0&quot; AnchorPane.rightAnchor=&quot;0.0&quot; AnchorPane.topAnchor=&quot;0.0&quot;&amp;gt; &amp;lt;children&amp;gt; &amp;lt;Button mnemonicParsing=&quot;false&quot; onMouseReleased=&quot;#onSelectEncodeSource&quot; text=&quot;选择文件&quot; /&amp;gt; &amp;lt;ChoiceBox fx:id=&quot;choiceBox&quot; prefWidth=&quot;100.0&quot; /&amp;gt; &amp;lt;TextField fx:id=&quot;textField&quot; alignment=&quot;TOP_CENTER&quot; maxWidth=&quot;200.0&quot; prefHeight=&quot;24.0&quot; prefWidth=&quot;200.0&quot; /&amp;gt; &amp;lt;Button mnemonicParsing=&quot;false&quot; onMouseReleased=&quot;#onEncode&quot; text=&quot;编码&quot; /&amp;gt; &amp;lt;/children&amp;gt; &amp;lt;padding&amp;gt; &amp;lt;Insets bottom=&quot;10.0&quot; left=&quot;10.0&quot; right=&quot;10.0&quot; top=&quot;10.0&quot; /&amp;gt; &amp;lt;/padding&amp;gt; &amp;lt;/VBox&amp;gt; &amp;lt;/children&amp;gt; &amp;lt;/AnchorPane&amp;gt; &amp;lt;/content&amp;gt; &amp;lt;/Tab&amp;gt; &amp;lt;Tab text=&quot;哈夫曼解码&quot;&amp;gt; &amp;lt;content&amp;gt; &amp;lt;AnchorPane minHeight=&quot;0.0&quot; minWidth=&quot;0.0&quot; prefHeight=&quot;180.0&quot; prefWidth=&quot;200.0&quot;&amp;gt; &amp;lt;children&amp;gt; &amp;lt;VBox alignment=&quot;TOP_CENTER&quot; prefHeight=&quot;342.0&quot; prefWidth=&quot;600.0&quot; spacing=&quot;20.0&quot;&amp;gt; &amp;lt;children&amp;gt; &amp;lt;Button mnemonicParsing=&quot;false&quot; onMouseReleased=&quot;#onSelectDecodingOrigin&quot; text=&quot;选择文件&quot; /&amp;gt; &amp;lt;Button mnemonicParsing=&quot;false&quot; onMouseReleased=&quot;#onDecoding&quot; text=&quot;解码&quot; /&amp;gt; &amp;lt;/children&amp;gt; &amp;lt;padding&amp;gt; &amp;lt;Insets bottom=&quot;10.0&quot; left=&quot;10.0&quot; right=&quot;10.0&quot; top=&quot;10.0&quot; /&amp;gt; &amp;lt;/padding&amp;gt; &amp;lt;/VBox&amp;gt; &amp;lt;/children&amp;gt;&amp;lt;/AnchorPane&amp;gt; &amp;lt;/content&amp;gt; &amp;lt;/Tab&amp;gt; &amp;lt;/tabs&amp;gt; &amp;lt;/TabPane&amp;gt; &amp;lt;/children&amp;gt;&amp;lt;/AnchorPane&amp;gt;package fexla.codec.view;import fexla.codec.Entrance;import fexla.codec.haffuman.Haffuman;import javafx.fxml.FXML;import javafx.scene.control.ChoiceBox;import javafx.scene.control.TextField;import javafx.stage.FileChooser;import java.io.*;public class Controller { @FXML private ChoiceBox choiceBox; @FXML private TextField textField; public void initialize() { choiceBox.getItems().addAll(new String[]{&quot;无编码&quot;, &quot;UTF-8&quot;, &quot;Unicode&quot;, &quot;ASCII&quot;, &quot;ISO_8859_1&quot;, &quot;其他&quot;}); choiceBox.getSelectionModel().select(0); textField.setVisible(false); choiceBox.addEventHandler(ChoiceBox.ON_HIDING, event -&amp;gt; { if (choiceBox.getSelectionModel().getSelectedItem() == null) return; if (choiceBox.getSelectionModel().getSelectedItem().equals(&quot;其他&quot;)) { textField.setVisible(true); } else { textField.setVisible(false); } }); } private File encodeSouce; private File encodeTarget; private File decodeOrigin; private File decodeTarget; @FXML private void onSelectEncodeSource() { encodeSouce = SelectFile(encodeSouce == null ? null : encodeSouce.getPath(), new FileChooser.ExtensionFilter(&quot;任意文件&quot;, &quot;*.*&quot;), true); } @FXML private void onEncode() { encodeTarget = SelectFile(encodeTarget == null ? null : encodeTarget.getPath(), new FileChooser.ExtensionFilter(&quot;哈夫曼编码二进制&quot;, &quot;*.haf&quot;), false); if (encodeTarget == null) return; if (encodeSouce == null) return; decodeOrigin = encodeTarget; String[] args = null; String str = (String) choiceBox.getSelectionModel().getSelectedItem(); if (!str.equals(&quot;无编码&quot;)) { if (str.equals(&quot;其他&quot;)) { args = new String[]{textField.getText()}; } else { args = new String[]{str}; } } File logFile = new File(encodeTarget.getPath() + &quot;.log&quot;); try { logFile.createNewFile(); encodeTarget.createNewFile(); OutputStreamWriter logger = new OutputStreamWriter(new FileOutputStream(logFile)); FileInputStream is = new FileInputStream(encodeSouce); Haffuman haffuman = new Haffuman(logger); byte[] bytes = haffuman.Encode(is, args); FileOutputStream os = new FileOutputStream(encodeTarget); os.write(bytes); logger.flush(); logger.close(); is.close(); os.flush(); os.close(); } catch (IOException e) { e.printStackTrace(); } } private File SelectFile(String initalPath, FileChooser.ExtensionFilter filter, boolean isOpen) { FileChooser fileChooser = new FileChooser(); fileChooser.setTitle(&quot;打开&quot;); if (initalPath != null) fileChooser.setInitialDirectory(new File(initalPath).getParentFile()); else fileChooser.setInitialDirectory(new File(System.getProperty(&quot;user.dir&quot;))); if (filter != null) fileChooser.getExtensionFilters().add(filter); File selectedFile; if (isOpen) selectedFile = fileChooser.showOpenDialog(Entrance.stage); else selectedFile = fileChooser.showSaveDialog(Entrance.stage); if (selectedFile == null) return null; return selectedFile; } @FXML private void onDecoding() { decodeTarget = SelectFile(decodeTarget == null ? null : decodeTarget.getPath(), new FileChooser.ExtensionFilter(&quot;任意文件&quot;, &quot;*.*&quot;), false); if (decodeTarget == null) return; if (decodeOrigin == null) return; File logFile = new File(decodeTarget.getPath() + &quot;.log&quot;); try { logFile.createNewFile(); decodeTarget.createNewFile(); OutputStreamWriter logger = new OutputStreamWriter(new FileOutputStream(logFile)); FileInputStream is = new FileInputStream(decodeOrigin); Haffuman haffuman = new Haffuman(logger); byte[] bytes = haffuman.decode(is); FileOutputStream os = new FileOutputStream(decodeTarget); os.write(bytes); logger.flush(); logger.close(); is.close(); os.flush(); os.close(); } catch (Exception e) { e.printStackTrace(); } } @FXML private void onSelectDecodingOrigin() { decodeOrigin = SelectFile(decodeOrigin == null ? null : decodeOrigin.getPath(), new FileChooser.ExtensionFilter(&quot;哈夫曼编码二进制&quot;, &quot;*.haf&quot;), true); }}" }, { "title": "动态属性网络框架-5 可视化（二）", "url": "/posts/%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6-5-%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BA%8C/", "categories": "游戏, 框架设计", "tags": "游戏, 游戏开发, 框架设计, 动态数值网络, 数值, 编程, UI", "date": "2021-11-23 00:00:00 +0800", "snippet": "基本思路　　可视化的第二步，可视化编辑属性网络模型。先搭建窗口的基本形状搭建窗口的基本形状　　新建两个类。AttrNetWindow继承EditorWindow、ModelGraph继承GraphView，分别是编辑属性网络模型的窗口和模型的GraphView控件。　　ModelGraph初始化。public ModelGraph (){ style.minHeight = 400; style.minWidth = 400; //拖拽背景 this.AddManipulator (new ContentDragger ()); //拖拽节点 this.AddManipulator (new SelectionDragger ()); //拖拽选择 this.AddManipulator (new RectangleSelector ()); this.AddManipulator (new FreehandSelector ()); //背景 var grid = new GridBackground (); Insert (0, grid); grid.StretchToParentSize ();}　　AttrNetWindow中有一个节点网络的画布，左上角有一块方形的属性栏。AttrNetWindow初始化：private void CreateGUI (){ //基本属性设置 name = &quot;Model Net Editor&quot;; minSize = new Vector2 (900, 600); //创建GraphView ModelGraph modelGraph = new ModelGraph (); modelGraph.StretchToParentSize (); modelGraph.styleSheets.Add (sheet); rootVisualElement.Add (modelGraph); //创建属性栏 _toolBox = new Box{ style ={ maxWidth = 275, marginLeft = 23, marginTop = 23 } }; rootVisualElement.Add (_toolBox);}　　　　动态属性网络模型是若干个动态属性作为节点形成网络，动态属性都有属性类型且互不相同。所以在模型编辑界面应该显示出一个属性类型的列表，双击其中的属性类型条目可以创建节点。　　导入字典资源_dictionary = AttrTypeDictionary.Dictionary;　　创建列表空间并和字典资源链接：Action&amp;lt;VisualElement, int&amp;gt; bind = (element, i) =&amp;gt; ((Label)element).text = _dictionary.Types[i].KeyName;listView = new ListView (_dictionary.Types, 24, CreateListLabel, bind);listView.selectionType = SelectionType.Multiple;listView.name = &quot;属性类型列表&quot;;listView.showBorder = true;　　用TabbedView包装List并添加到根元素上：TabbedView tabbedView = new TabbedView ();tabbedView.AddTab (new TabButton (&quot;属性类型列表&quot;, listView), true);_toolBox.Add (tabbedView);　　如果属性字典改变了窗口内的列表并不会更新，所以要添加一个当窗口得到焦点时更新列表：private void OnFocus (){ listView?.Refresh ();}　　表列里的Label都要添加监听，如果双击则创建节点。先写一个CreateListLabel方法，创建节点的逻辑先留着之后写：private Label CreateListLabel (){ Label label = new Label (); label.AddToClassList (&quot;ListLabel&quot;); label.RegisterCallback&amp;lt;ClickEvent&amp;gt; ((type) =&amp;gt; { if (type.clickCount == 2){ Debug.Log (label.text + &quot;双击&quot; + _dictionary.Types.Count); } }); return label;}　　最后uss文件写上样式，美化一下：GridBackground { --grid-background-color: rgb(1, 6, 28); --line-color: rgba(193, 196, 192, 0.1); --thick-line-color: rgba(193, 196, 192, 0.1); --spacing: 10;}Box { background-color: rgba(49, 49, 49, 0.8); border-radius: 5px; height: 300px;}ListView { margin: 2px; min-height: 70px; height: 65px;}Label { -unity-font-style: normal; color: rgb(241, 241, 241); font-size: 17px; margin: 6px;}.ListLabel { font-size: 14px; padding: 5px; padding-left: 10px;}TabbedView { margin: 6px; width: 100%; height: 160px; background-color: rgba(40, 40, 42, 0.9);}TabButton Label { font-size: 14px;}　　加载样式表：sheet = LoadStyle ();rootVisualElement.styleSheets.Add (sheet);　　最终效果" }, { "title": "动态属性网络框架-4 可视化（一）", "url": "/posts/%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6-4-%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%80/", "categories": "游戏, 框架设计", "tags": "游戏, 游戏开发, 框架设计, 动态数值网络, 数值, 编程, UI", "date": "2021-11-22 00:00:00 +0800", "snippet": "基本思路　　需求是可视化地使用动态属性网络框架。首先需要实现可视化地编辑属性类型字典。要做的包括持久化字典类，字典编辑窗口，属性类型信息的编辑UI。持久化字典类　　类型字典类继承ScriptableObject，让它可以被unity持久化。在字典类中添加以下代码（dictionary是公共静态的字典变量）：public static AttrTypeDictionary Dictionary{ get =&amp;gt; dictionary ??= Load ();}public static AttrTypeDictionary Load (){ AttrTypeDictionary _asset; _asset = AssetDatabase.LoadAssetAtPath&amp;lt;AttrTypeDictionary&amp;gt; ( &quot;Assets/Config/Attribute System/Type Dictionary.asset&quot;); if (!_asset){ _asset = CreateInstance&amp;lt;AttrTypeDictionary&amp;gt; (); if (!AssetDatabase.IsValidFolder (&quot;Assets/Config/Attribute System&quot;)){ if (!AssetDatabase.IsValidFolder (&quot;Assets/Config&quot;)){ AssetDatabase.CreateFolder (&quot;Assets&quot;, &quot;Config&quot;); } AssetDatabase.CreateFolder (&quot;Assets/Config&quot;, &quot;Attribute System&quot;); } AssetDatabase.CreateAsset (_asset, &quot;Assets/Config/Attribute System/Type Dictionary.asset&quot;); } return _asset;}　　（创建文件夹写的有点繁琐了，以后再优化吧）字典编辑窗口　　用一个窗口类继承EditorWindow，是编辑字典的窗口。　　添加以下代码，在目录中添加打开窗口的选项。[MenuItem (&quot;Window/Attribute/Type Dictionary&quot;)]public static void open (){ GetWindow&amp;lt;TypeDictionaryWindow&amp;gt; (&quot;Type Dictionary&quot;);}　　另外，当尝试打开持久化字典类的文件时，就打开窗口。[OnOpenAsset (1)]public static bool OnOpenAsset (int instanceID, int line){ if (AssetDatabase.GetAssetPath (instanceID)==&quot;Assets/Config/Attribute System/Type Dictionary.asset&quot;){ open (); return true; } return false;}　　如果是匹配类型，可以这么写： if (EditorUtility.InstanceIDToObject (instanceID) is AttrTypeDictionary)　　接下来填充窗口内容。当打开窗口时，加载储存的字典对象，new一个SerializedObject包装加载的字典对象（功能是提供读写字典对象属性的接口，然后给InspectorElement用），用包装好的对象绑定到InspectorElement组件，添加到窗口的根节点，用处是调出unity自带的属性编辑功能。代码如下：private void CreateGUI (){ InspectorElement inspector = new InspectorElement (); SerializedObject serializedObject = new SerializedObject (_asset); inspector.Bind (serializedObject); rootVisualElement.Add (inspector);}　　效果如图：　　但这还没达到理想效果，因为list中的元素是类型信息类，没有对应的编辑UI。属性类型信息的编辑UI　　要让unity知道怎么编辑这个自己写的类型信息类、显示UI，要用IMGUI写类型信息的自定义PropertyDrawer。　　新建一个TypeInfoDrawer类，继承PropertyDrawer，在类前面加上CustomPropertyDrawer的Attribute。 [CustomPropertyDrawer (typeof (AttrTypeInfo))] public class TypeInfoDrawer : PropertyDrawer{ }　　绘制label和textfield：Rect labelRect = new Rect (position.x, position.y + 1, 50, position.height - 2);Rect textRect = new Rect (position.x + 60, position.y + 1, position.width - 80, position.height - 2);EditorGUI.LabelField (labelRect, &quot;类型名 : &quot;);EditorGUI.PropertyField (textRect, property.FindPropertyRelative (&quot;_keyName&quot;), GUIContent.none);　　用PropertyField新建输入框可以让输入框和这个编辑的属性绑定。　　到这里已经能正常编辑了，但我还希望在数组中的类型信息前面的label显示出类型id。unity并没有直接提供可以得知上下文情况的接口，但是我发现了property.propertyPath，它代表这个属性的路径，当这个类型信息在数组中时，它的路径类似_types.Array.data[4]，通过正则表达式等操作就可以达到我的目的。　　核心代码如下：public override void OnGUI (Rect position, SerializedProperty property, GUIContent label){ EditorGUI.BeginProperty (position, label, property); string pattern = @&quot;Array\\.data\\[[0-9]+\\]&quot;; string path = property.propertyPath; Regex r = new Regex (pattern); Rect labelRect = new Rect (position.x, position.y + 1, 50, position.height - 2); Rect textRect = new Rect (position.x + 60, position.y + 1, position.width - 80, position.height - 2); if (r.Match (path).Success){ int result = Int32.Parse (Regex.Replace (path, @&quot;[^0-9]+&quot;, &quot;&quot;)); EditorGUI.PropertyField (textRect, property.FindPropertyRelative (&quot;_keyName&quot;), GUIContent.none); EditorGUI.LabelField (labelRect, &quot;类型&quot; + (result + 1) + &quot; : &quot;); } else{ EditorGUI.LabelField (labelRect, &quot;类型名 : &quot;); EditorGUI.PropertyField (textRect, property.FindPropertyRelative (&quot;_keyName&quot;), GUIContent.none); } EditorGUI.EndProperty ();}　　效果图：批量添加属性类型　　创建批量导入窗口，窗口类继承unity提供的对话框ScriptableWizard类。在TypeDictionaryWindow中加入按钮打开对话框。其中 “批量导入类型”表示窗口title， “确定”, “取消”分别表示主按钮确定，还有一个按钮取消。TypeDictionaryImortWindow imortWindow;Button button = new Button (() =&amp;gt; { imortWindow = ScriptableWizard.DisplayWizard&amp;lt;TypeDictionaryImortWindow&amp;gt; (&quot;批量导入类型&quot;, &quot;确定&quot;, &quot;取消&quot;); imortWindow.MainEdit = this;});button.text = &quot;批量导入&quot;;rootVisualElement.Add (button);　　写回调函数，外部写入TypeDictionaryWindow属性，也就是编辑字典的主窗口，当点击确定时，执行导入操作。（主按钮点击后自动关闭窗口）private TypeDictionaryWindow _mainEdit;private TextField _textField;public TypeDictionaryWindow MainEdit{ set =&amp;gt; _mainEdit = value;}private void OnWizardCreate (){ _mainEdit.ImportTypes (_textField.value);}　　在TypeDictionaryWindow中添加方法：public void ImportTypes (string txt){ _asset.AddList (AttrTypeInfo.ReadListFromTxt (txt));}　　点击取消按钮关闭窗口：private void OnWizardOtherButton (){ Close ();}　　对话框主体部分是一个label和在ScrollView里的一个多行textfield，调整了距离使得整个对话框看起来正常：private void OnEnable (){ rootVisualElement.Add (new Label{ text = &quot;输入批量导入文本&quot;, style ={ marginTop = 50, marginLeft = 10, marginRight = 10 } }); ScrollView scrollView = new ScrollView{ style ={ minHeight = 100, maxHeight = 270, marginLeft = 10, marginRight = 10 } }; _textField = new TextField{ multiline = true, style ={ minHeight = 60 } }; scrollView.Add (_textField); rootVisualElement.Add (scrollView); minSize = new Vector2 (320, 370);}　　最终效果" }, { "title": "动态属性网络框架-3 类型系统", "url": "/posts/%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6-3-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/", "categories": "游戏, 框架设计", "tags": "游戏, 游戏开发, 框架设计, 动态数值网络, 数值, 编程", "date": "2021-11-16 00:00:00 +0800", "snippet": "需求　　在动态属性网络中需要使用一个东西来指代属性类型。我这里直接使用int来表示一个类型，而不用string主要是因为hash速度快（c#中直接返回本身）。　　用一个类来保存属性类型信息，再用一个类型字典的类来动态维护类型。当一个属性类型被删除的时候，其他属性类型的编号不应该变化，同时需要从类型名得到类型编号。实现　　类型信息里暂时只有一个string类型的keyName，表示类型名。　　类型字典有一个类型信息的动态数组，删除类型时把对应位置设置为null，添加类型时优先找空位，没有空位再Add；有一个类型名到类型编号的哈希表，每当类型信息数组发生变化，哈希表同步变化。其他功能　　除了上面写的功能之外，还有 AttrTypeDictionary.Contains方法：返回是否包含 AttrTypeDictionary.Initialize方法：通过类型信息数组初始化字典 AttrTypeDictionary.AddList方法：批量添加 AttrTypeInfo.ReadListFromTxt方法：从字符串批量创建类型信息对象 源码public class AttrTypeInfo{ private string _keyName; public string KeyName{ get =&amp;gt; _keyName; set =&amp;gt; _keyName = value; } public AttrTypeInfo (string keyName){ _keyName = keyName; } public static List&amp;lt;AttrTypeInfo&amp;gt; ReadListFromTxt (string txt){ string[] array = txt.Split (&#39;|&#39;); List&amp;lt;AttrTypeInfo&amp;gt; list = new List&amp;lt;AttrTypeInfo&amp;gt; (); for (var i = 0; i &amp;lt; array.Length; i++){ list.Add (new AttrTypeInfo (array[i])); } return list; }}public interface IAttrTypeDictionary{ public void Initialize (); public int Add (AttrTypeInfo value); public void AddList (List&amp;lt;AttrTypeInfo&amp;gt; infoList); public bool Contains (string keyName); public bool Contains (int type); public int GetId (string name); public AttrTypeInfo GetTypeInfo (string name); public AttrTypeInfo GetTypeInfo (int id); public void Remove (string key); public void Remove (int id); public void Rename (int id, string name); public void Rename (string origin, string name);}public class AttrTypeDictionary : IAttrTypeDictionary{ public static AttrTypeDictionary dictionary; private List&amp;lt;AttrTypeInfo&amp;gt; _pos; private Dictionary&amp;lt;string, int&amp;gt; _mapping; static AttrTypeDictionary (){ dictionary = new AttrTypeDictionary (); } public AttrTypeDictionary (){ dictionary = this; _mapping = new Dictionary&amp;lt;string, int&amp;gt; (); _pos = new List&amp;lt;AttrTypeInfo&amp;gt; (); } public void Initialize (){ dictionary = this; _mapping = new Dictionary&amp;lt;string, int&amp;gt; (); for (var i = 0; i &amp;lt; _pos.Count; i++){ _mapping.Add (_pos[i].KeyName, i); } } public int Add (AttrTypeInfo value){ if (_mapping.ContainsKey (value.KeyName)){ throw new KeyExistedException (); } for (var i = 0; i &amp;lt; _pos.Count; i++){ if (_pos[i] == null){ _pos[i] = value; _mapping.Add (value.KeyName, i); return i + 1; } } int j = ((System.Collections.IList)_pos).Add (value) + 1; _mapping.Add (value.KeyName, j - 1); return j; } public void AddList (List&amp;lt;AttrTypeInfo&amp;gt; infoList){ foreach (var attrTypeInfo in infoList){ Add (attrTypeInfo); } } public bool Contains (string keyName){ return _mapping.ContainsKey (keyName) &amp;amp;&amp;amp; _pos[_mapping[keyName]] != null; } public bool Contains (int type){ if (type &amp;gt; _pos.Count){ return false; } return _pos[type - 1] != null; } public int GetId (string name){ if (_mapping.ContainsKey (name)){ return _mapping[name] + 1; } return -1; } public AttrTypeInfo GetTypeInfo (string name){ return _pos[_mapping[name]]; } public void Remove (string key){ if (_mapping.ContainsKey (key)){ _pos[_mapping[key]] = null; _mapping.Remove (key); } } public void Remove (int id){ if (id &amp;gt; _pos.Count || _pos[id - 1] == null){ return; } _mapping.Remove (_pos[id - 1].KeyName); _pos[id - 1] = null; } public void Rename (int id, string name){ string origin = _pos[id - 1].KeyName; _pos[id - 1].KeyName = name; _mapping.Remove (origin); _mapping.Add (name, id - 1); } public void Rename (string origin, string name){ int id = _mapping[origin]; _pos[id].KeyName = name; _mapping.Remove (origin); _mapping.Add (name, id); } public AttrTypeInfo GetTypeInfo (int i){ return _pos[i - 1]; }}11/20更新　　刚刚学到c#的用户定义转换运算符，新建了一个属性类型结构体，重写了所有接口，看起来舒服了一些 。public struct AttrType{ public int Type{ get; set; } public AttrType (int type){ Type = type; } public AttrType (string type){ Type = AttrTypeDictionary.dictionary.GetId (type); } public static implicit operator AttrType (int i) =&amp;gt; new AttrType (i); public static implicit operator AttrType (string type) =&amp;gt; new AttrType (type); public static implicit operator int (AttrType type) =&amp;gt; type.Type; public static implicit operator string (AttrType type) =&amp;gt; AttrTypeDictionary.dictionary.GetTypeInfo (type.Type).KeyName; public static bool operator == (AttrType t1, AttrType t2){ return t1.Type == t2.Type; } public static bool operator != (AttrType t1, AttrType t2){ return !(t1 == t2); } }" }, { "title": "动态属性网络框架-2 基本功能实现", "url": "/posts/%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6-2-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/", "categories": "游戏, 框架设计", "tags": "游戏, 游戏开发, 框架设计, 动态数值网络, 数值, 编程", "date": "2021-11-13 00:00:00 +0800", "snippet": "动态属性网络模型属性模型　　动态属性网络模型的作用是维护各个属性之间的运算关系，并提供一个从一个从数据集得到特定属性的值的接口。　　各个属性之间的运算关系是一个图，或者说一个网络。我使用一个结构体ModelNode储存一个节点的信息，用结构体动态数组来保存表示各个属性之间的运算关系。​ 一个ModelNode包含：属性类型，三个动态数组分别储存这个属性计算时涉及哪些属性（储存的是动态数组中保存涉及的属性的索引），涉及的属性的计算方式（比如是加上去的还是按百分比提高），哪些属性计算时会涉及到这个属性，如果这个节点是一个数字节点，则还要保存一个数字属性的对象。　　用ModelNode的数组就可以描述各个属性之间的运算关系了。　　当我们需要得到某个属性的值的时候，就递归地取值计算，如上图我想知道node5代表的属性的值，就先得到node的值，然后发现node是数字属性，于是先得到node1,node2的值，进行计算后得到node的值然后进行计算后得到node5的值。　　在这个过程中我们可以设置缓存，每次计算后保存结果，下次取值就直接返回缓存而不用再进行取值和计算，直到会影响到这个节点的节点发生了改变，就清空缓存。清空缓存的操作也是递归地，如果要清空node1，则要去清空node，然后清空node3，node4，node5。（缓存是保存在数据集中的）　　因为这个网络需要频繁地索引到某个属性，所以我们用List储存ModelNode，而因为外部调用时还是得用属性的类型来调用，所以再额外开个哈希表，保存从属性类型到List位置的映射。　　每个模型会储存一个版本变量，构造模型的时候版本值为随机数，每次有改变版本值就加一。数值集　　数值集用List保存了一系列的数值实例，它们的索引和对应在对应模型的Node节点的索引相同。　　数值集提供一个添加数字属性的接口，用于实现类似buff，装备这些频繁变化的效果。数字属性需要附加在特定的动态属性身上，数字属性会有一个NumModifier结构体的数组，一个NumModifier结构体包含了数字属性和计算方式。" }, { "title": "使用图床给我的博客添加图片", "url": "/posts/%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BA%8A%E7%BB%99%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/", "categories": "水, 工具使用", "tags": "水, 博客, 工具使用", "date": "2021-11-12 00:00:00 +0800", "snippet": "事情是这样的于是我就百度了一个图床，叫路过图床。用起来很方便，简单弄弄就能用了。下面是一个实例。markdown的代码如下![IBZuZt.png](https://z3.ax1x.com/2021/11/12/IBZuZt.png){: width=&quot;200&quot; height=&quot;400&quot;}又水了一篇博客呢，真好" }, { "title": "使用PlantUML制作程序示意图", "url": "/posts/%E4%BD%BF%E7%94%A8PlantUML%E5%88%B6%E4%BD%9C%E7%A8%8B%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE/", "categories": "水, 工具", "tags": "水, 工具使用, 编程, 效率提升", "date": "2021-11-12 00:00:00 +0800", "snippet": "感觉不用UML来解释自己的程序还是太难说清楚了，所以我在Rider里装了一个PlantUML的插件，简单学了一下用法。下面是大概效果：@startumlleft to right directionmap node1{ from =&amp;gt; to}map node2{ from =&amp;gt; to}map node{from =&amp;gt; to}node1::to --&amp;gt; node : Addnode2::to --&amp;gt; node : Addmap node3{ from =&amp;gt; to}map node4{ from =&amp;gt; to}map node5{ from =&amp;gt; to}node::to --&amp;gt; node3 : Addnode::to --&amp;gt; node4 : Increasenode::to --&amp;gt; node5 : Increase@enduml@startumlleft to right directionmap node1{ from =&amp;gt; to}map node2{ from =&amp;gt; to}map node{from =&amp;gt; to}node1::to --&amp;gt; node : Addnode2::to --&amp;gt; node : Addmap node3{ from =&amp;gt; to}map node4{ from =&amp;gt; to}map node5{ from =&amp;gt; to}node::to --&amp;gt; node3 : Addnode::to --&amp;gt; node4 : Increasenode::to --&amp;gt; node5 : Increase@enduml感觉还是比较好用的。更多的用法要去看官网plantuml" }, { "title": "动态属性网络框架-1 前言", "url": "/posts/%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6-1-%E5%89%8D%E8%A8%80/", "categories": "游戏, 框架设计", "tags": "游戏, 游戏开发, 框架设计, 动态数值网络, 数值, 编程", "date": "2021-11-11 00:00:00 +0800", "snippet": "简介　　我最近设计开发了一个游戏数值（程序，）框架，我将它命名为动态属性网络（节点是动态属性的动态网络），其作用是用一个可视化的、动态的数值模型，维护多级属性的所有属性之间的运算关系，和维护数值载体身上的一系列数值。它适用于开发数值属性非常多的游戏，如太吾绘卷、鬼谷八荒、群星。　　我的基本想法是：以太吾绘卷为例（觉得文字太繁琐可以直接看我的示意图），太吾绘卷有非常多的属性种类，属性之间又会互相影响。首先是人物五维：膂力、体质、灵敏、根骨、悟性、定力（众所周知五维有六个）五维，然后是技艺/功法水平，加起来共30种，每一种由先天资质加后天造诣相加算出，资质属性又会受到年龄的影响。人物会有很多功法，每个功法有特定的功法需求，功法需求会有若干个五维和技艺/功法水平的要求，人物对应的属性值低于要求时功法带来的属性加成和功法威力会降低，反之亦然，另一方面功法学习进度也会影响。由上面这些属性又会推导出几十种战斗中直接用到的属性，会影响内/外伤害，移动速度，招式/平a回转速度，招式生效段数，平a连击概率等等。除此之外还有内功产生的五种内力数量（五行内力）、玩家自己分配的摧破、轻灵、护体、奇窍点数、精纯境界。　　很容易发现的是，我们几乎没法用一个公式直接算出一个最终属性的值，我们要先把底层的数值算出来，然后一层一层推算到最后。在动态属性框架中，把一个不可再分的属性（即上图的一个大方块中的一行）看做一个节点，节点之间的运算逻辑连接相关节点，比如剑法资质、剑法造诣、剑法水平看做三个属性节点，剑法资质节点和剑法水平节点之间有一条连线，同理剑法造诣节点和剑法水平节点之间有一条连线。在这个框架中，把所有属性抽象为节点，于是可以动态地、可视化地增加删除属性和属性之间的运算关系。最终节点和节点相连的效果就是形成网络。概念解释　　这里有动态属性网络模型和属性集。　　什么是动态属性呢？这里的定义就是这个属性会因为其他某个或某几个属性的变化而变化，就是动态属性。　　属性网络模型保存了属性之间的运算关系，属性集保存了一系列实际的属性实例。属性网络模型是游戏开发阶段，由开发人员编辑出属性之间的关系，属性集在游戏运行时产生，是实际的属性。属性集要按照某一个模型构建，属性网络模型可以依靠属性之间的运算关系对属性集操作（比如得到某个属性的值）。如果属性集由模型A构建，那么它只能被模型A操作。　　举个具体的例子就是假设有个“战斗单位”的属性模型，描述了力量和攻击力之间的运算关系（比如力量直接加到攻击力上），玩家A，玩家B，NPC_A，NPC_B都分别有一个属性集，都是按照“战斗单位”这个属性模型构建的，他们的属性集包括力量，攻击力这两个属性。　　还有一些更具体的功能，比如 函数式属性（本身是一个属性模型，用于技能输出的计算） 网络依附（一个属性集依附到另一个属性上，用于多对一的关系，比如一个人穿4个装备） 属性类型从属（用于一次性影响多个属性，比如群星中一个科技增加2%所有人口的产出）　　这些功能先放着，之后的文章再详细写。优缺点这个框架的优点有： 可视化编辑属性模型，由节点表示运算关系，比公式直观。 可以在每个节点设置缓存，可以空间换时间，减少运算量，尤其对于底层数值不易改变的场景。 属性模型可以热更新，即运算公式可以热更新。因为属性模型可以序列化。 因为完全用图形化界面，所以属性类型的枚举不用在c#中写，而是用图形化界面操作一个int到类型信息的表。 可以直接用字符串指代属性类型而不用写枚举。（因为字符串哈希的运算量，只在中间属性使用并且没有buff附加到它身上才不会影响性能 这个框架的缺点有： 网络无法处理循环连接。 等实现出来再看有什么缺点。 修改记录　　2021/11/14 发现讲的不清楚，于是加上了太吾绘卷的例子，修改了一些说法。" }, { "title": "素描练习记录-01", "url": "/posts/%E7%B4%A0%E6%8F%8F%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95-01/", "categories": "画画, 练习记录", "tags": "画画, 素描, 练习记录, 我好菜", "date": "2021-11-10 00:00:00 +0800", "snippet": "一个多月没练习了，拿出来练一下这是我第一次素描脑海中的物体感觉画的还是有点奇怪😶" }, { "title": "游戏中的外部空间设计", "url": "/posts/%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%A4%96%E9%83%A8%E7%A9%BA%E9%97%B4%E8%AE%BE%E8%AE%A1/", "categories": "游戏, 游戏设计", "tags": "游戏, 游戏设计, 作业", "date": "2021-11-08 00:00:00 +0800", "snippet": "正文​　　游戏中的外部空间设计可以起到非常多的作用，好的设计可以指引玩家做出设计师预想中的行为，可以调动玩家的情绪。每个游戏都发生在某种空间中，相比于现实，游戏的空间可以不是连续而是离散的，可以不是三维而是二维甚至一维的（比如九宫格游戏中的空间就可以视为一维空间上9个离散的点）或是在零维上（比如“二十问”这类的游戏），可以是若干个连接或不连接的有界区域。这里我们讨论的空间是指游戏中视觉角度上的三维、连续的空间。​　　要说外部空间的设计，首先要讨论空间的形成。空间基本上是由一个物体同感觉它的人之间产生的相互关系所形成的。在游戏中，这一相互关系主要根据视觉确定，但还会受到听觉（游戏的背景音乐，人物的走路声音等）和游戏机制的影响。比如，在游戏《我的世界》中进入洞穴之后，游戏会播放阴森、空旷的音乐，让玩家明显地感觉到空间的改变；如果玩家进入到蘑菇岛的地形，蘑菇岛上不会刷新敌对怪物的游戏机制又会迅速给玩家建立起进入蘑菇岛空间的感受。​　　那么什么是建筑外部空间呢？与无限伸展的自然状态不同的， 人为地在自然中划定的，有规划的一块有意义的外部环境。所以外部空间设计就是创造设计一块有意义的外部环境。外部空间又可划分为积极空间和消极空间。积极空间是指被框框所包围，从人为划分的边界向内的向心秩序的，创造出来的满足人的意图和功能的空间。消极空间是指自然产生的、无限延伸的离心空间。空间的积极性在于空间满足人的意图，或者说有计划性，即确定外围边框区整顿秩序，具有收敛性。空间的消极性在于空间自然发生，无计划性，即从内侧向外侧增加扩散性，具有扩散性。比如有一栋孤单的建筑，建筑向外就会产生无限的消极空间，如果还有一栋靠近的建筑，两栋建筑就会相互影响，中间产生一块积极空间。再比如欧洲城市中被建筑所围绕的广场就是典型的积极空间。​　　游戏中的外部空间设计有特殊性。在现实中把建筑周围作为积极空间设计，即把整个用地作为一座建筑来设计时，才是外部空间设计。而游戏完全是由设计师所设计的，不论是收敛的积极空间还是向外无限延伸的消极空间，亦或是玩家自己可能会创造出来的空间都由设计师设计。另一方面区别于现实中外部空间有散步、集体活动、休息、欣赏景色、饮食等多种多样的功能，游戏中外部空间的功能性非常单一。​　　游戏中的积极空间与消极空间会给人不相同的感受。这种感受会随着游戏的题材、机制、剧情、游戏进度等因素的改变而改变，但大上积极空间会给人安全，放松的感觉，容易让玩家注意力放在单个目标上，而消极空间会给人不安全、紧张的感觉，玩家在消极空间中往往会注意观察周围。​　　外部空间的要素有：尺度——外部空间可以用内部空间尺寸的8-10倍，也称为十分之一理论，或外部空间可采用一行程为20-25的模数，称之为外部模数理论；质感——距离和质感是设计要点。外部空间的设计手法有： 首先通过运动和停滞来考虑空间，尽可能赋予该空间明确的用途，根据这一前提来确定空间的大小、铺装的质感、墙壁的造型、地面的高差等；将外部空间有意识地渗透到建筑内部——比如日本银座的索尼大厦中道路的延续等，外部空间有了目标，途中的空间才产生吸引力，而途中的空间有了吸引力，目标也就更加突出。​　　下面我将举出几个游戏中外部空间设计的例子来研究游戏中的外部空间设计。1.《永劫无间》　　《永劫无间》是一款武侠、玄幻题材的大逃杀动作游戏。​　　因为游戏题材和机制的缘故，游戏中绝大部分的外部空间都属于消极空间，比如空旷的，容易发生交战的田野、树林，时刻保持一个紧张的感受符合大逃杀这个游戏机制。但如果整个地图都是消极空间会太过单调，《永劫无间》中所有高资源点都有一块半封闭的积极空间，这些积极空间会吸引附近玩家的注意。在玩家群体自己发展出的“练刀”玩法中（几个到十几个玩家开启自定义房间切磋游戏的格斗技术），绝大部分情况下玩家们都会主动集中在这些积极空间中。这些积极空间的收敛性更适合玩家们进行切磋，同时在这些区域注意力更容易集中在对手身上符合“练刀”这个玩法。​　　《永劫无间》灵活的运动系统（包含跳跃、攀爬、翻窗、钩索）允许玩家飞檐走壁，玩家可以通过钩锁直接从外部飞跃进建筑内部，让外部空间渗透到了建筑内部，建筑的内部和外部的联系更加紧密。玩家对于空间的距离感受因为灵活的运动系统大大缩小了。​　　游戏中，如果玩家身处于落日寺附近，游戏背景音乐会变为空明、神圣的音乐，给玩家对于这个空间独特的感受。2.《我的世界》​　　《我的世界》是一款3d沙盒生存游戏。​　　在这个游戏中，天然的洞穴是四通八达的，形成一块消极空间，同时洞穴特有的背景音乐又加强了玩家紧张的感受，但是如果玩家使用方块堵上支路的通道，围出一块安全的区域，就会马上产生一块收敛的、满足人的意图和功能的积极空间，玩家再布置上火把、熔炉、工作台等，这片空间又会进一步有了生产物资的作用。​　　游戏中的火把可以照亮一片区域，同时防止敌对怪物的生成。这一设计从视觉和游戏机制两方面让玩家只需要在地面上放置一根火把就可以简单地构建出一块积极空间，在周围密集地布置火把就可以构建一大片的积极空间。但是这样布置火把并不美观，实际上可以更进一步思考如何让类似的设计视觉上更加美观。​　　我认为《我的世界》在早期版本的树林的外部空间设计上是有问题的。游戏自然生成的树太过低矮，甚至有时候树叶会阻碍玩家的移动，过于低矮的树和这样的树林对于玩家的视觉感受也较差；树林的地面质感和草原的地面质感没有区别，树叶颜色和草地颜色过于接近，树林和草原空间区分不明显。以上都不符合玩家对树林这个空间的概念。这些问题在更新版本新更新的树林和玩家自制的树林都有一定程度上的解决。比如更高、更大的大型树木、云杉树林独特的灰色土壤、丛林由植物铺成的崎岖地面、各种更加精美的树叶、树叶落在地上形成一层树叶等等。​　　总而言之，游戏中好的外部空间设计可以让空间契合游戏的玩法、机制，可以改善游戏的视觉效果，可以在恰当的时机给予玩家恰当的体验。游戏开发者可以在设计游戏可以从这一角度来设计游戏场景。参考文献[1]芦原义信.外部空间设计[M].背景建筑工业出版社.1985.[2]Jesse Schell.游戏设计艺术：第3版[M].电子工业出版社.2021.其他　　这篇文章实际上是我的课程作业，我自己都觉得很一般。。　　姑且发到这里吧 🙃 。" } ]

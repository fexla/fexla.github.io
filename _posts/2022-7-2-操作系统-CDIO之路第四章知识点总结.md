---
title: 《操作系统-CDIO之路》第四章存储管理 知识点总结
date: 2022-07-02
categories: [编程, 操作系统]
tags: [编程, 操作系统, 读书笔记]    # TAG names should always be lowercase
excerpt: 存储器是计算机系统的重要资源之一。
---

存储器是计算机系统的重要资源之一，由内存（主存储器）和外存（辅存储器）构成。

**内存储器（简称内存、主存、物理存储器）**：处理机能直接访问的存储器。用来存放系统和用户的程序和数据，其特点是存取速度快，存储方式是以新换旧，断电信息丢失。价格昂贵

**外存储器（简称外存、辅助存储器）**：处理机不能直接访问的存储器。用来存放用户的各种信息，存取速度相对内存而言要慢得多，但它可用来长期保存用户信息。在文件系统中介绍。价格便宜

**物理地址**：把内存分成若干个大小相等的存储单元，每个单元给一个编号，这个编号称为内存地址（物理地址、绝对地址、实地址），存储单元占8位，称作字节（byte）。

**物理地址空间**：物理地址的集合称为物理地址空间（主存地址空间），它是一个一维的线性空间。

**程序地址（逻辑地址 、虚地址 ）**：用户编程序时所用的地址，基本单位可与内存的基本单位相同，也可以不相同。

**程序地址空间（逻辑地址空间、虚地址空间）**:用户的程序地址的集合称为逻辑地址空间，它的编址总是从0开始的，可以是一维线性空间，也可以是多维空间。

<img src="https://s2.loli.net/2022/07/02/d2YV78tCJgfkLbx.png" alt="image-20220702193438381" style="zoom: 50%;" />

## 4.1 存储管理的基本功能

### 4.1.1 转换

用户通过汇编语言或高级语言编写的程序，称为源程序。源程序需要通过编译、连接、加载后才能运行。 

#### 连接和加载
连接可以分为两种方式：静态连接和运行时动态连接。

**静态连接**：在程序运行之前，将各个目标模块及它们所需的库函数连接成一个完整的执行文件。

静态链接需要将目标模块中使用的符号地址转换为可执行文件中使用的数字地址，静态链接需要：
- 修改相对地址

- 变换外部调用符号

  <img src="https://s2.loli.net/2022/07/02/SqiFDEXukOvmpxc.png" alt="image-20220628150109513" style="zoom:50%;" />

**运行时动态连接**：指在程序运行时进行连接，通常被连接的共享代码称为动态连接库（DLL, Dynamic-Link Library）或共享库（Shared Library）。

优点：

- 共享：多个进程可以共用一个 DLL，节省内存，减少文件交换
- 部分装入：一个进程可以将多种操作分散在不同的 DLL 中实现，而只将当前操作相应的 DLL 装入内存，加快程序的装入过程。
- 便于局部代码修改：便于代码升级和代码重用，只要函数的接口参数（输入和输出）不变，则修改函数及其 DLL，只需对可执行文件重新编译或连接
- 便于运行环境适应：调用不同的 DLL，就可以适应多种使用环境和提供不同功能。如：不同的显示卡只需厂商为其提供特定的 DLL，而 OS 和应用程序不必修改。

缺点：

- 连接开销：增加了程序执行时的连接开销

- 管理开销：程序由多个文件组成，增加管理复杂度。

  

加载：绝对加载、可重定位加载和运行时动态加载。

- **绝对加载**：要求加载模块总是被加载到主存中的同一个单元。因此，在提供给加载器的加载模块中，所有的地址访问必须是绝对地址。
- **可重定位加载**：在加载时就把对主存的访问绑定到具体的主存地址。缺点是程序一旦装入内存后将不能再移动，且必须在程序执行之前将程序全部装入。
- **运行时动态加载**：把对主存访问（绝对地址）的计算推迟到程序运行中真正需要时。基于这个目的，加载模块被加载到主存时，它的所有主存访问都以相对形式表示，只有一条指令真正被执行时才计算绝对地址。为确保该功能不会降低性能，这些工作必须由特殊的处理器硬件完成。

#### 地址转换
地址转换：把进程的逻辑地址转换为内存的物理地址， 或称为重定位。 核心问题：把一维或多维的逻辑地址空间变换到内存一维的物理地址空间中，建立逻辑地址与物理地址的映射。

实现地址转换的方式：**静态地址重定位**和**动态地址重定位**。

**静态地址重定位**：程序装入内存时，由加载模块把进程中的指令地址全部转换为物理地址。

<img src="https://s2.loli.net/2022/07/02/87cbnxDuKQTfZEB.png" alt="image-20220628150634773" style="zoom: 50%;" />

**动态地址重定位**：在程序执行过程中，在CPU访问内存之前，将要访问的程序或数据地址转换成内存地址。

动态地址重定位依靠硬件地址变换机构完成：
地址重定位机构需要一个（或多个）基地址寄存器BR和一个（或多个）程序虚拟地址寄存器VR。

内存地址MR与虚拟地址的关系为：MR=BR+VR。

<img src="https://s2.loli.net/2022/07/02/TSvbH4my1oDQr5X.png" alt="image-20220628211354407" style="zoom:50%;" />

在动态地址重定位中，源程序、逻辑地址空间和物理地址空间的关系:

<img src="https://s2.loli.net/2022/07/02/NTHznOuXvI1Zxyt.png" alt="image-20220628211619856" style="zoom:50%;" />

- 动态地址映射是由硬件在执行时完成的，程序中不执行的程序就不做地址映射的工作，这样节省了CPU时间。
- 重定位寄存器的内容由操作系统用特权指令来设置，比较灵活。
- 实现动态地址映射必须有硬件的支持，并有一定的执行时间延迟。现代计算机系统中都采用动态地址映射技术。
- 动态地址重定位可以对内存进行非连续分配
- 可以实现虚拟存储器
- 有利于程序段共享。

### 4.1.2 存储保护和共享

在多道程序设计的环境下，系统中有系统程序和多个用户程序同时存在，并且可能共享程序和数据，如何保证用户程序不破坏系统程序，用户程序之间不相互干扰？这就是存储保护所要解决的问题。

常用的存储保护有三种：

- **硬件法**：上下界保护法。
- **软件法**：保护键法。为每个保护存储区分配一个保护键，可保护对该存储区的读写操作。保护键就是一个标志，标志能否被读写。
- **软件与硬件结合**：界限寄存器与与CPU用户态或核心态工作方式结合。用户进程只能访问界限寄存器所规定的范围，核心态进程可以访问整个内存区域

#### 上下界寄存器保护法

上下界寄存器保护法是一种**硬件保护法**：为每个进程设置一对装有程序起始地址和结束地址的上下界寄存器。在程序执行中，对内存的访问始终对所访问的地址进行检查，越界则产生中断。

<img src="https://s2.loli.net/2022/07/02/pJt7ZH46TVL1bIP.png" alt="image-20220628212049651" style="zoom:50%;" />

例：
```
     有一程序装入内存的首地址是500，末地址是1500，访问内存的逻辑地址是500、345、1200。
     下界寄存器：500
     上界寄存器：1500
     逻辑地址＋装入内存的首地址＝ 物理地址
     1、500＋500 ＝ 1000      500  ≤   1000 ≤   1500 √
     2、345＋500 ＝ 845        500  ≤   845 ≤   1500 √
     3、1200＋500 ＝ 1700    500  ≤   1700 ≤  1500 ×
```

#### 保护键法

保护键法是一种**软件保护法**：
       为每一个被保护的存储块分配一个单独的保护键，在**程序状态字**中则设置相应的**保护键开关字段**，对不同的进程赋予不同的开关代码和与被保护的存储块中的保护键进行**匹配**。

<img src="https://s2.loli.net/2022/07/02/CmnL2NFcGk7EBvH.png" alt="image-20220628212451451" style="zoom: 33%;" />

#### 界限寄存器与CPU工作方式结合

在这种方式下，用户态进程只能访问那些在界限寄存器所规定的的内存区域，而核心态进程则可以访问整个内存地址空间。

UNIX系统就是采用这种保护方式。

### 4.1.3 内存分配和回收

存储管理要为每一个并发执行的进程分配内存空间，当进程执行结束时，要及时地回收该进程所占用的内存资源，以便给其他进程分配空间。 

内存的分配方式，可以分为三种：连续分配方式、离散分配方式和虚拟存储管理方式。

- **连续分配方式**：为一个系统或用户程序分配一个连续的空间.
- **离散分配方式**：将一个用户程序离散地分配到内存中的多个不相连续的区域中。以减少因连续分配所产生的碎片，提高内存的利用率。
- **虚拟存储管理方式**：前两种分配方式，当进程大小超出内存的可用空间时，进程是无法运行的。为了解决这个问题，通过实现部分装入和部分对换功能，形成了虚拟存储管理方式。

<img src="https://s2.loli.net/2022/07/02/gtLbzJn4de6W3UR.png" alt="image-20220628212717252" style="zoom: 33%;" />

### 4.1.4 内存扩充

**内存扩充**：把内存中不能运行的进程换出，或把外存中具备运行条件的进程换入内存。

内存扩充的方式：

1. 由**应用程序控制**的：覆盖方式；
2. 由**操作系统控制**的：交换方式、请求调入方式和预调入方式。


分区存储管理的优点：

- 支持多道程序设计，实现了多个进程对内存的共享。提高了内存和CPU的利用效率
- 分区存储管理的原理简单，所需硬件支持较少，容易实现

分区存储管理的缺点：

- 分区存储管理要求进程在分区内连续存储，进程大小受内存空间容量的限制
- 分区存储管理难以实现存储共享
- 固定分区分配算法会产生内部碎片，动态分区分配算法会产生外部碎片，内存利用率不高

## 4.2 分区存储管理

#### 分区管理的基本原理

给装入内存的作业划分一块存储区域，以连续存储进程相关的全部指令和数据，若用户区中存在多个进程，则它们可以并发执行。

分区管理是多道程序设计下的一种最简单的存储管理方法。

####  分区管理的方法

- 固定分区法

- 动态分区法

#### 4.2.1 固定分区

固定分区(fixed partition)：把内存空间分成若干个大小不等的区域，称为分区。每个用户程序（作业、进程）调入内存后，占用其中一个分区，程序运行完成后释放该分区。操作系统占用其中一个分区。

一旦划分完成，在系统运行期间内存不再重新划分，即分区的位置不可变，分区的个数不可变，分区的大小不可变。 

<img src="https://s2.loli.net/2022/07/02/KmS1lQCRXh7T5Ev.png" alt="image-20220628213223371" style="zoom:50%;" />

特点：

- 适用于多道程序系统和分时系统。
- 支持多个程序并发执行
- 难以进行内存分区的共享。

问题：可能存在内碎片和外碎片。

- 内碎片：占用分区之内未被利用的空间
- 外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）。

#### 4.2.2 动态分区

动态分区，又称变长分区，指根据进程大小，动态地为之分配内存空间。

可以克服固定分区中小进程占据大分区的现象，避免分区内部出现碎片，提高内存空间的有效利用率。

在进程进入内存前并不建立分区，而是根据进程大小对内存进行划分，因此，内存中分区个数是可变的。

<img src="https://s2.loli.net/2022/07/02/YexioN84q9Mhjl6.png" alt="image-20220628213627985" style="zoom:50%;" />

在动态分区下，系统初启时，用户区是一个大区域。随着进程的执行，内存空间将被划分成许多个分区。当新进程将被装入时，判断用户区的空闲区域是否足够大，如果大于进程需求量，则将空闲区按进程大小分成两个部分，一部分分配给进程，另一部分又称为一个较小的空闲区。

随着时间的推移，内存空间中会产生越来越多的碎片，这种现象称作外部碎片。

为了减少外部碎片的浪费，必须对空闲区进行**紧凑**（或称拼凑，Compaction）——通过移动，把分散的多个小分区拼接成大分区。即向一个方向（例如向低地址端）移动已分配的进程，使那些零散的小空闲区在另一方向连成一片。

动态分区管理中何时对内存空间进行紧凑：

1. 在某个分区被释放后立即进行紧凑

2. 当请求分配找不到足够大的自由分区分给用户时，使用紧凑

<img src="https://s2.loli.net/2022/07/02/D4pIjtdCUyu59ic.png" alt="image-20220628213558841" style="zoom:50%;" />


### 4.2.3 地址转换和存储保护

固定分区存储管理的地址转换可以采用**静态地址重定位**和**动态地址重定位**。

**静态地址重定位**：在进程装入前，进行地址转换，并检查其物理地址是否在分区的指定长度中，若是，则装入，否则发生地址越界，不能装入。

**动态地址重定位**：当一个进程被 CPU 执行时，操作系统从分区说明表中根据占有标志取出其相应的起始地址和分区长度，分别置入上限/下限寄存器；

在执行过程中，硬件的地址转换机构根据下限寄存器中的值 B 与指令的逻辑地址相加后得到物理地址，同时将物理地址与上限寄存器中的值进行比较，若在分区长度内，则执行指令；否则，产生一个中断，表明地址越界，从而实现存储保护。 

<img src="https://s2.loli.net/2022/07/02/5FUM3JHmRlqcOfD.png" alt="image-20220628213759775" style="zoom:50%;" />

### 4.2.4 存储共享

无论是固定分区，还是动态分区，进程在各个分区内都是连续存储的，因而不允许各个分区之间有公共区域。

当几个进程共享某些指令和数据时，各个进程只能在各自分区内各放一个副本。

因此，分区存储管理难以实现各分区间的信息共享。

### 4.2.5 分配和回收算法

分配：存储管理程序根据请求表查询分区说明表，从中找出一个满足要求的空闲分区，并将其分配给申请者。

#### 固定分区的分配

<img src="https://s2.loli.net/2022/07/02/bhHCnWv7aGlFTuD.png" alt="image-20220630220705486" style="zoom:50%;" />



<img src="https://s2.loli.net/2022/07/02/ODFH18aGy2uq6YW.png" alt="image-20220628213901828" style="zoom:50%;" />

#### 动态分区的内存分配算法

对于动态分区的内存分配算法，当一个进程将被装入时，若内存中存在多个空闲区，则操作系统必须考虑分配哪个分区。这属于分配策略的问题，通常考虑的方式有三种：

- **最先适应法**(first fit algorithm)
- **最佳适应法**(best fit algorithm)
- **最坏适应法**(worst fit algorithm)。 

**最先适应法**

1. 将空闲分区表中的表项按起始地址的递增顺序排列
2. 每次分配时，根据进程大小，算法从分区说明表的表头开始顺序查找，找到第一个大于或等于进程大小的空闲区，则停止查找
3. 从所找到的分区中划出所要求的内存长度给用户
4. 如果余下部分有相邻空闲区存在，则使用紧凑对其合并后重新进入可用分区表，并修改调整分区说明表

最先适应法的目的在于**减少查找时间**，具有以下特点：

- 该算法分配分区和释放分区的时间性能较好，较大的空闲分区可以被保留在内存高端；
- 随着低端分区不断划分而产生较多小分区，每次分配时查找时间开销会增大。

<img src="https://s2.loli.net/2022/07/02/nAVMY9u2BsbFQ43.png" alt="image-20220630221016470" style="zoom: 33%;" />

**最佳适应法**

1. 将空闲分区表的表项按从小到大的**递增**次序排列

2. 每次分配时，根据进程大小，算法从分区说明表的表头开始顺序查找，找到第一个大于或等于进程大小的空闲区，则停止查找
3. 从所找到的分区中划出所要求的内存长度给用户
4. 如果余下部分有相邻空闲区存在，则使用紧凑对其合并后重新进入可用分区表，并修改调整分区说明表

最佳适应法的目的在于**使碎片尽量小**。它从全部空闲区中找出能满足进程要求的、且为最小的空闲区。

最佳适应算法具有以下特点：

- 从局部来看，外碎片较小

- 从整体来看，会形成较多外碎片
- 较大的空闲区可以被保留。

**最坏适应法**

1. 将空闲分区表按从大到小的递减顺序排列

2. 每次分配时，根据进程大小，算法从分区说明表的表头开始顺序查找。若第一个空闲区的大小就小于进程大小，则分配失败。否则，找到第一个大于或等于进程大小的空闲区，则停止查找
3. 从所找到的分区中划出所要求的内存长度给用户
4. 如果余下部分有相邻空闲区存在，则使用紧凑对其合并后重新进入可用分区表，并修改调整分区说明表

**几种分配算法的比较**

| **算法** | 最先适应法(first-fit)：                                      | 最佳适应法(best-fit)：                                       | 最坏适应法(worst-fit)：                                      |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **优点** | **该算法的分配和释放的****时间性能较好****。不需要对空闲区进行排队，在释放时不必重新调整空闲区的位置。** | **能找到最佳空闲区****，从个别来看，内碎片较小，较大的空闲分区可以被保留。** | **基本不留下小空闲分区。**                                   |
| **缺点** | **随着低端分区不断划分而产生较多小分区，每次分配时查找时间开销会增大。** | **从整体来看，会形成较多外碎片。而且这些外碎片很难再被利用。**  **分配和回收时有很大查找负担。** | **较大的空闲分区不被保留。**  **分配和回收时有很大查找负担。** |

#### 动态分区的回收算法 

回收：当进程执行完毕，不再需要内存资源时，管理程序将对应的分区状态置为未使用。

当一个进程运行结束释放内存时，系统根据释放区的首地址，从空闲分区表中找到相应的插入点，此时可能出现下图所示的四种情况，其中 F 1 ，F 2 表示回收区的前、后空闲区。

<img src="https://s2.loli.net/2022/07/02/Eev53omTCxp2ByD.png" alt="image-20220630221406468" style="zoom:50%;" />

**移动技术**

当在空闲分区表中找不到一个足够大的空闲区来装入进程，而所有剩余空闲区的大小却能容纳时，就可采用移动技术，改变内存中进程的存放区域，从而使分散的空闲区汇集成一片，便于进程装入。

<img src="https://s2.loli.net/2022/07/02/uVIROnsiQYk21WE.png" alt="image-20220630221557660" style="zoom:50%;" />

移动技术实质是为了提高内存利用率，对相邻的空闲区进行拼接，从而得到更大的空闲区。

### 4.2.6 覆盖和交换 

覆盖与交换是解决大进程与小内存矛盾的两种存储管理技术，实质上是对主存进行了逻辑扩充。覆盖技术主要用于早期的操作系统中；交换技术仍用于今天的操作系统。

#### 覆盖技术

覆盖(overlay)技术指：同一主存区可以被不同的程序段重复使用。 

**引入**：其目标是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用。

**原理**：一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。

1. 将程序的必要部分（常用功能）的代码和数据常驻内存
2. 可选部分（不常用功能）在其他程序模块中实现，平时存放在外存中（覆盖文件），在需要用到时才装入到内存
3. 不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。(即不同时用的模块可共用一个分区)

<img src="https://s2.loli.net/2022/07/02/C4wrxdKZzfNjyIp.png" alt="image-20220630222138220" style="zoom: 50%;" />

#### 交换技术

交换技术是指：操作系统根据需要把主存中暂时不运行的某个进程移动到外存交换区，从而获得空闲内存空间来装入新程序，然后把外存交换区中的某个进程移到相应的主存区，并使其投入运行。

常用于多道程序系统或小型分时系统中，与分区存储管理配合使用。又称作"对换"或"滚进/滚出(roll-in/roll-out)"；

<img src="https://s2.loli.net/2022/07/02/qwNF9hiDjGXnYd7.png" alt="image-20220630222227868" style="zoom:50%;" />

交互过程中，交换单位为整个进程的地址空间。

将整个进程的地址空间保存到外存的交换区中（换出swap out）

而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，并将该进程送到就绪队列（换入swap in）。

### 4.2.7 分区存储管理的优缺点

分区存储管理的优点：

- 支持多道程序设计，实现了多个进程对内存的共享。提高了内存和CPU的利用效率

- 分区存储管理的原理简单，所需硬件支持较少，容易实现

分区存储管理的缺点：

- 分区存储管理要求进程在分区内连续存储，进程大小受内存空间容量的限制
- 分区存储管理难以实现存储共享
- 固定分区分配算法会产生内部碎片，动态分区分配算法会产生外部碎片，内存利用率不高




## 4.3 分页式存储管理

提出分页式存储管理的原因：

1. 分区管理方式存在着严重的碎片问题使得内存的利用率不高。
2. 进程的大小仍受分区大小或内存可用空间的限制。
3. 分区管理不利于程序段和数据的共享。


### 4.3.1 基本原理

- 各进程的虚拟地址空间被划分成若干个长度相等的页（page）。页长的划分和内存外存之间数据传输速度以及内存大小等有关，一般为1-4K。

- 物理内存空间也按页的大小划分为页面（page frame）。这些页面为系统中的任一进程所共享。
- 分页管理把页式虚拟地址与内存物理地址建立一一对应的页表，并用相应的硬件地址变换机构，来解决离散地址变换。
- 分页式存储管理允许把一个进程分配到不相邻的分区中。这种方式实现了程序的不连续存储，避免产生外部碎片，充分利用了内存空间。

- 经过页划分后，进程的虚地址变为页号与页内地址所组成。

<img src="https://s2.loli.net/2022/07/02/ehCdAZMi1rX28qD.png" alt="image-20220630222525278" style="zoom:33%;" />

分页管理时，用户进程在内存空间中除了在每个页面内地址连续之外，每个页面之间不再连续。第一是避免产生外部碎片，充分利用了内存空间。第二是实现了由连续存储到非连续存储的飞跃，为在内存中局部地，动态地存储那些反复执行或即将执行的程序和数据打下了基础。

### 4.3.2 数据结构

分页式管理在进程开始执行之前，把该作业或进程的程序段和数据全部装入内存的各个页面内，并通过页表和硬件地址变换机构，实现逻辑地址（虚地址）到物理地址的转换。 

1. **页表：记录页号与页面号的对应关系**

页表是操作系统为每个用户进程建立的，在内存中占有一块固定的区域。页表用来记录程序页和内存页面的一一对应关系。每个页在页表中占一个表项，记录该页在内存中对应的物理页面。

<img src="https://s2.loli.net/2022/07/02/4taqVxnjsyMJNFl.png" alt="image-20220628184148006" style="zoom:50%;" />

2. **作业表：记录正在运行作业的页表地址**

作业表是操作系统为当前运行的所有作业建立的，用来记录每个作业的页表起始地址和页表长度，以进行内存分配和地址变化。整个系统一张作业表。

<img src="https://s2.loli.net/2022/07/02/2sRGukEe1hQyWAV.png" alt="image-20220630222618591" style="zoom:50%;" />


3. **存储页面表：记录内存分配情况**

存储页面表也是操作系统建立的，用来记录内存分配情况，指出已分配的页面和尚未分配的页面。整个系统一张存储页面表。

存储页面表的两种实现方法 ：1、位示图法；2、链表法。 

- 位示图法：在内存中划分一块固定区域用于存放此表，表格中的每一位代表一个页面，如果该页面已被分配，则对应表格设置为 1，否则设置为 0。

<img src="https://s2.loli.net/2022/07/02/d2Q97afj8ZkquNe.png" alt="image-20220630222740093" style="zoom:33%;" />


- 链表法：表中每一项都含有以下内容：进程占用区(P)或者空闲区(H)、页表起始地址、页表长度和指向下一表项的指针。

<img src="https://s2.loli.net/2022/07/02/wVCksrUe1Z2EQR4.png" alt="image-20220628184337028" style="zoom:50%;" />

### 4.3.3 地址转换和存储保护

#### 地址转换

采用动态地址重定位。调度程序在选择作业后，从作业表的登记项中得到被选中作业的页表起始地址和页表长度，将其送入硬件设置的页表控制寄存器。地址转换时，先从页表控制寄存器中找到相应的页表，再以页号为索引从页表中找到对应的页面号，并根据下列公式计算出要访问内存单元的物理地址：

物理地址 = 页面号 × 页面长度 + 页内地址

<img src="https://s2.loli.net/2022/07/02/Lm91EDaQHOtkCou.png" alt="image-20220628184436010" style="zoom:50%;" />



#### 分页式管理的存储保护

两种方式：

1. 地址越界保护。在进行地址变换的过程中，将页号与页表长度进行比较，如果页号大于页表长度，则越界中断。
2. 通过页表控制对内存信息的操作方式以提供保存。在页表中增加一些标志位，用来定义该页面的相关授权操作：只读、读写、只写、只可执行等。若试图向只读页面中写入信息，则指令会停止执行，并产生中断信号。

### 4.3.4 分配算法

<img src="https://s2.loli.net/2022/07/02/9SzDPyjn8Ewo65h.png" alt="image-20220628184808258" style="zoom:50%;" />

### 4.3.5 存储共享

分页式存储管理能实现多个进程共享程序和数据 ，但在共享时，**必须区分数据共享和程序共享**。 

数据共享时，允许不同的进程对共享的数据页使用不同的页号，但要确保各个进程页表中的有关表目都指向共享的数据页面块。 

程序共享时，必须保证代码是**可重入代码**。

可重入代码是一种允许多个进程同时访问的代码，是一种不允许任何进程对其进行修改的代码。但在每个进程中，配以局部数据区，将在执行中可能改变的部分，复制到该数据区。当程序执行时，只对该数据区（进程私有）中的内容进行修改，而不去改变共享的代码，这时的可共享代码即成可重入代码。	

<img src="https://s2.loli.net/2022/07/02/b51OUgA9HdqjkML.png" alt="image-20220628185108366" style="zoom: 33%;" />

### 4.3.6 分页式存储管理的优缺点

优点：

1. 不要求各个页面之间连续存储，实现了离散存储，可以避免产生外部碎片。
2. 实现了由连续存储到非连续存储的飞跃，为在内存中局部、动态地存储那些反复执行或即将执行的程序和数据打下了基础，也为以后实现程序的“部分装入、部分对换”奠定基础。

缺点：

1. 消除了外部碎片，但内部碎片仍然存在
2. 分页式存储管理在进行地址转换和存储保护时，需要有相应的硬件支持，增加了机器成本

## 4.4 分段式存储管理

### 4.4.1 基本原理

在分区存储管理和分页式存储管理中，进程的逻辑地址空间按线性排列。虽然把程序划分成区或页，但这些区或页与源程序的公用子程序和数据毫无逻辑关系。而共享程序或数据往往按照程序名或数据块调用，所以不同进程之间共享公用子程序和数据变得非常困难。

为了更好地实现公用子程序和数据的共享，把用户进程按逻辑关系划分成若干个段，每个段有自己的名字，从零开始编址。

**分段式存储管理**：以段为基本单位，对进程进行划分，要求每一段分配一个连续的存储空间，而各段之间不一定连续。每段都有逻辑名、并具有完整的逻辑意义 。

一个程序可以分为若干程序段：主程序段、若干子程序段、若干数据段，每段的地址都从“0”开始编址，每段都有逻辑名、并具有完整的逻辑意义。 

对源程序进行编译、连接时，分段式存储管理要求把进程的**逻辑地址空间**设计为二维结构，即段号和段内地址 。

与分页式存储管理相比，分段式存储管理有两个显著的特征：

1. 在分页式存储管理中，内存中的页面号递增排列，地址空间属于一维结构。而在分段式存储管理中，段号在内存中的分区之间无任何顺序关系，地址空间属于二维结构
2. 在分页式存储管理中，每个页的长度固定。而在分段式存储管理中，为了确保信息在逻辑上是完整的，段的长度可变。分段式存储管理为进程的每一段分配一个连续内存空间，而各个段之间并不要求一定连续


### 4.4.2 地址转换和存储保护

#### 地址转换

为了实现地址变化，将进程的逻辑地址（二维）转换为物理地址（一维），操作系统为每个进程建立一张段映射表，简称为“段表”。段表实现从逻辑段到物理内存区的映射。

| **段号** | **始址** | **段长** | **存取方式** |
| -------- | -------- | -------- | ------------ |
|          |          |          |              |
|          |          |          |              |

为实现缺段中断处理和存储保护，段表增加了两个字段：段号、存取方式。
段号与用户指定的段名一一对应；始址和段长分别表示该段在内存或外存的物理地址与实际长度；存取方式用来对该段进行存取保护。

调度程序从作业表中得到被选中作业的段表起始地址和段表长度，将其送入硬件设置的段表控制寄存器。

| **作业名** | **段表起始地址** | **段表长度** |
| ---------- | ---------------- | ------------ |
| A          | 1024             | 40           |
| B          | 1064             | 40           |
| C          | 1104             | 60           |

地址转换时，从段表控制寄存器中找到相应的段表，然后以虚地址的段号 s 为索引，从段表中找到相应的表目。若该段在内存中，则将其起始地址和段内相对地址相加，得到该段在内存中的实际物理地址。若该段不在内存中，则产生缺段中断将 CPU 控制权交给内存分配程序。内存分配程序首先检查空闲区链表，以确定能否找到足够长度的空闲区来装入所需要的段。如果不能找到，则检查段表中的访问位，淘汰那些访问概率低的段，并根据外存的始址将该段调入。

分段式存储管理的地址变换需要访问内存二次：第一次先访问段表以计算得到待访问指令或数据的物理地址，然后才对物理地址进行取数据或存数据。 

<img src="https://s2.loli.net/2022/07/02/GUJnYCdWlOAgv2D.png" alt="image-20220628194638692" style="zoom:50%;" />

#### 储存保护

1. 地址越界保护法：利用段表中的段长项与虚拟地址中的段内相对地址比较，确定是否越界。若段内地址大于段长，则系统会产生保护中断。但在允许段长动态增长的系统中，段内相对地址可以大于段长。
2. 存取方式控制保护法

### 4.4.3 储存共享

分段式存储管理，支持按段名访问内存空间=>更好地实现内存信息

共享段的共享：多个用户进程通过使用相同的段名，在新的段表中填入共享段的起始地址，并置以适当的读写控制权，就可以共享一段逻辑上完整的程序和数据。

当多个进程并发执行共享段时，共享段不能被修改，并且不能将正在或将要执行的共享段换出内存，这个机制可以通过在段表中设置共享位来实现。

<img src="https://s2.loli.net/2022/07/02/25fjndArHyFsDgq.png" alt="image-20220628200218022" style="zoom: 67%;" />

### 4.4.4 分段式存储管理的优缺点

优点：

1. 有利于实现信息共享
2. 动态增长：段长可根据需要动态增长
3. 动态连接：当运行过程中需要调用某段时，再将该段（目标程序）调入内存并连接起来。动态连接是以段为基础的
4. 提供了内外存统一管理的虚拟存储器的实现

缺点：

1. 需要有更多的硬件支持，提高了机器成本
2. 在内存空闲区管理方式上与分区式存储管理相同，存在碎片问题
3. 缺段中断处理、动态增长会给系统增加难度和开销，有可能会产生抖动现象

抖动：由于置换算法选择不当，导致整个系统调度非常频繁，大部分时间都花在内存和外存之间的来回调入调出上，这个现象称为抖动。

## 4.5 段页式存储管理

### 4.5.1 基本原理

分段是信息的逻辑单位，由源程序的逻辑结构决定，用户可见，段长可根据用户需要来动态增长。因此，分段式存储管理是基于用户程序结构的存储管理技术，有利于模块化程序设计，有利于段的动态增长及共享和内存保护 ，但往往会产生碎片问题。

分页是信息的物理单位，与源程序的逻辑结构无关，用户不可见，页长不可动态改变。分页式存储管理是基于系统存储器结构的存储管理技术，可以避免产生外部碎片，提高了内存的利用率，但不易实现存储共享。

段页式管理将段式管理和页式管理结合起来，取长补短。

内存：将整个内存划分成大小相等的、位置固定的页面。

进程：将一个进程中所包含的具有独立逻辑功能的程序或数据划分成段，并为每个段赋予一个段名。

把每段的线性地址空间划分成与页面大小相等的页，和页式管理一样，最后不足一页的部分仍占一页。

段页式管理中，进程的虚拟地址由三部分组成：段号s，段内页号p，页内相对地址d：

<img src="https://s2.loli.net/2022/07/02/V3yszah9LDiA6Sm.png" alt="image-20220628201034153" style="zoom:33%;" />

对程序员而言，虚拟地址仍可视为由段号s和段内相对地址w组成，地址变换机构会把w的高几位解释为段内页号p，把剩下的部分解释为页内位移d。满足w = p×块长 + d

段页式存储管理的数据结构，包括作业表、段表和页面三级结构。

整个系统一张作业表，用于记录系统中所有作业的段表的起始地址；每个作业一张段表，用于记录该作业的所有段以及每段的页表起始地址；每个段一张页表，把段中的虚页变换成内存中的实际页面。 

<img src="https://s2.loli.net/2022/07/02/s8wpkr5JO4RQFTt.png" alt="image-20220628201442188" style="zoom:50%;" />

段页式管理系统中，如果要对内存中的指令或数据进行一次存取，至少需要访问三次以上的内存：
第一次：由段表地址寄存器得到段表始址去访问段表，由此取出对应段的页表地址；
第二次：访问页表得到所要访问的物理地址；
第三次：访问真正的内存物理单元。

<img src="https://s2.loli.net/2022/07/02/U6xdqNo28fV3pKD.png" alt="image-20220628202022620" style="zoom:50%;" />

### 4.5.3 段页式存储管理的优缺点

优点：段页式存储管理具有分页式存储管理和分段式存储管理的优点。

缺点：所需的硬件支持、复杂性和系统开销也会随之增加。在地址转换过程中，如果不采用快表提高地址转换速度，那么CPU的执行速度将大大下降。

为了提高地址转换速度，设置快速联想寄存器，存放当前最常用的段号s，页号p和对应的内存页面与其他控制项目。

如果所要访问的段或页在快速联想寄存器中，则系统不再访问内存中的段表、页表而直接把快速联想寄存器中的值与页内相对地址拼接起来得到物理地址。

经验表明，一个在快速联想寄存器中装有1/10左右的段号、页号及页面的系统，可以得到90%的命中率。

## 4.6 虚拟存储管理

### 4.6.1 虚拟存储器的概念

**部分装入**：当一个进程在执行过程中，若需要访问的指令和数据不在内存中，则系统把这部分信息自动调入内存，称为部分装入。

**部分对换**：若内存中没有足够多的空闲区，则系统需把内存中暂时不用的信息从内存中调出，称为部分对换。

**虚拟存储器**：系统自动实现部分装入和部分对换功能，只把进程的一部分装入内存便可运行，从逻辑上，是对内存容量进行了扩充的一种虚拟存储器，简称虚存。

虚拟存储管理采用以下几种技术实现：请求分页式虚拟存储管理、请求分段式虚拟存储管理、请求段页式虚拟存储管理。

### 4.6.2 请求分页式虚拟存储管理

#### 基本原理

请求分页式虚拟存储管理（请求页式管理），是在分页式存储管理的基础上，增加了**请求调页功能**和**页面置换功能**所形成的**页式虚拟存储系统**。它允许只装入若干页（而非全部程序）的用户程序和数据，就可启动运行，执行过程中再通过调页功能和页面置换功能，陆续把将要运行的页面调入内存，同时把暂不运行的页面置换到外存上，调入和置换均以页面为单位。

根据页面调入的时机不同分为两种方式：请求页式管理和预调入页式管理。

1. **请求页式管理**：当需要执行某条指令或访问某个数据时，发现它们不在内存中，发生缺页中断，系统从外存中把该指令或数据所在的页面调入内存。
2. **预调入页式管理**：一种主动的缺页调入策略。在进程运行过程中，动态预测进程所需要的页面，预先调入内存中，尽量确保进程所需的页面都已调入。 

#### 地址变换

请求页式管理的地址转换和存储保护与分页式管理的地址转换和存储保护基本相同，只是在请求页式管理时，由于只调入立即或经常使用的程序和数据，在进程执行过程中，不可避免地会产生缺页中断，要从外存中调入所需的程序和数据。因此，如何处理缺页中断，以及如何从内存中换出页，是请求页式管理必须解决的两个基本问题。

第一个问题的解决办法是扩充页表的内容。在页表原有页号和页面号的基础上，增加驻留标志位、外存始址和其他标志。

解决第二个问题的基本思路：当发生缺页中断时，需要根据所缺页的外存始址将该页从外存调入内存，如果内存中没有空闲页面，则应该使用置换算法选择一个页面淘汰，如果这个页面被写过或修改过，则应该把淘汰页的内容写回外存加以保存，在成功调入所缺页后， 应同时修改进程页表的相应表项。

**快表**是一块小容量的相联存储器（Associative Memory），由高速缓存器组成，速度快，并且可以从硬件上保证按内容并行查找，一般用来存放当前访问最频繁的少数活动页面的页号。快表的用途是加快线性地址的转换。

<img src="https://s2.loli.net/2022/07/02/zsqUfXi4kGoASgc.png" alt="image-20220628203147444" style="zoom: 80%;" />

#### 页面分配策略

页面分配是指在内存中为进程分配页面（分配存储空间）。

**固定分配**：保持页面数固定不变，只要发生一个缺页中断，就会有一页被替换掉。主要有：

- 平均分配算法;
- 按比例分配算法
- 优先权分配算法：把内存中可供分配的所有物理块分成两部分，一部分按比例分配给各进程，另一部分则根据各进程的优先权，适当地增加其相应份额 后，分配给各进程。

**可变分配**：进程生命周期中，分配的页面数可变。被许多操作系统使用，但困难于OS需要经常监视活动进程的缺页中断率，增加操作系统的开销。

#### 页面置换策略

页面置换是指对于请求页式管理，当进程执行产生缺页中断时，需要从外存把缺页调入内存，若内存空间已满无空闲页面时，则必须按一定的策略把内存中的某个页面调出，这个工作称为页面置换。

**局部替换**：页面置换算法从属于进程自己的页面中选择一个替换页面，其作用范围是本进程。 

**全局替换**：页面置换算法从所有的页面中选择一个替换页面，其作用范围是整个系统。 

#### 页面置换算法

置换算法的选择很重要，应该将那些访问概率最低的页调出内存。如果选择不当，容易产生抖动。

理想的置换算法，理想型淘汰算法OPT (Optimal replacement algorithm) ：当要从外存调入一个缺页而必须从内存中淘汰一个页面时，所淘汰的页应该是以后不再访问的页或距现在最长时间内不再访问的页。又称为最佳替换算法（Optimal）。

特点：无法预测进程的访问串，因而无法实现。

常用的置换算法：

1. **随机页面置换算法**：所淘汰页面由随机程序产生的随机数决定。 
2. **先进先出页面置换算法（FIFO）**：基于程序按线性顺序来访问物理空间这一假设，总是选择在内存中驻留时间最长的一个页面进行淘汰。 
3. **最近最久未使用页面置换算法（Least Recently Used,LRU）**:总是选择最近一段时间内最久没有使用过的页先淘汰。这种算法在操作系统、数据管理系统和文件系统中被广泛使用。

#### 先进先出页面置换算法（FIFO）

实现FIFO算法，需要把各个已分配的页面按分配时间顺序链接起来，组成FIFO队列，并设置一个置换指针指向FIFO的队首页面。

例1：进程P共有5页，其页面走向（访问串）为：1，2，3，4，1，2，5，1，2，3，4，5，若开始执行时主存中没有页面，如果分配给该进程的物理块数为 4 时，采用先进先出（FIFO）页面置换算法时的缺页次数和缺页率各是多少？

`（缺页次数就是缺页中断次数。缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问）`

<img src="https://s2.loli.net/2022/07/02/loMPteE9XqOd2JQ.png" alt="image-20220628204403300" style="zoom:50%;" />

例2：假设同前，如果分配给该进程的物理块数为 3 时，采用先进先出（FIFO）页面置换算法时的缺页次数和缺页率各是多少？

<img src="https://s2.loli.net/2022/07/02/rNn8bGIhCMPZTfv.png" alt="image-20220628204733869" style="zoom: 45%;" />

#### FIFO算法的Belady现象

在使用FIFO算法时，在未给进程分配它所要求的足够页面数时，有时会出现分配的页面数增多，缺页次数反而增加的奇怪现象，这种现象称为**Belady现象**。原因在于没有考虑到程序执行的动态特征。

<img src="https://s2.loli.net/2022/07/02/IVxEehgycKTBqGf.png" alt="image-20220628204922635" style="zoom:50%;" />

#### 最近最久未使用页面置换算法（Least Recently Used,LRU）

**算法主要出发点**：如果某页很长时间未被访问，则它在最近一段时间内也不会被访问。

**算法实现较困难**，因为必须为每个页面设置有关的访问记录项，且每次访问都必须更新记录。

#### 抖动

置换算法的选择很重要，应该将那些访问概率最低的页调出内存。如果选择不当， 有可能产生被调出内存的页又要马上调入内存，调回内存不久后马上又要被调出内存，如此反复的局面，使得处理器花费大量时间用于调换页面而不是执行计算任务，这种现象被称为 “抖动”(Thrashing)，又称“颠簸”。

### 4.6.3 请求分段式虚拟存储管理

#### 基本原理

请求分段式虚拟存储管理（请求分段式存储管理，请求分段管理）是在分段式存储管理的基础上，增加了**请求调段功能**和**分段置换功能**所形成的**段式虚拟存储系统**。它把进程所有分段的副本都存放在辅助存储器中，当进程运行时，首先只装入若干段（而非全部信息）的指令和数据，执行过程中再通过调段功能和置换功能，陆续把将要运行的段调入内存，同时把暂不运行的段置换到外存上，调入和置换均以段为单位。

为了实现请求分段式存储管理，在分段式存储管理的段表中需要增加若干项，以供系统在调入、调出时参考。

<img src="https://s2.loli.net/2022/07/02/wcDKEzdqfmPiQSX.png" alt="image-20220628205328825" style="zoom:50%;" />

**访问字段**：用于记录该段被访问的频繁程度；

**修改位**：用于表示该段进入内存后，是否已被修改过；

**存在位**：用于说明该段是否已调入内存；

**增补位**：用于表示该段在运行过程中，是否进行过动态增长；

**外存始址**：用于指示该段在外存中的起始地址。

#### 请求调段策略——缺段中断处理

在进程执行中访问某段时，若进程所要访问的段未调入内存，便由**缺段中断机构**产生缺段中断信号，由缺段中断处理程序将所需的段调入内存；若空闲区总和不能满足要求，则可调出一个或几个分段到外存上，再将该段调入内存。 

<img src="https://s2.loli.net/2022/07/02/ZcH7sEQbmA4GCqk.png" alt="image-20220628205531251" style="zoom: 50%;" />

#### 地址变换

请求分段系统中的地址变换机构，是在分段式存储管理地址变换机构的基础上形成的。 在进程执行期间，由于被访问的段并非全在内存中，所以在地址变换时，若发现所要访问的段不在内存中，必须先将所缺的段调入内存，并修改段表之后，才能再利用段表进行地址转换。为此，在地址变化机构中又增加了某些功能，如缺段中断的请求及处理等。

#### 分段共享与保护:

在请求分段系统中，用共享段表来记录每一个共享段的段号、段长、内存始址、存在位 等信息，并记录共享此分段的每个进程的情况。

<img src="https://s2.loli.net/2022/07/02/kMNm9XDZjVP3qsH.png" alt="image-20220628205746329" style="zoom:50%;" />

### 4.6.4 请求段页式虚拟存储管理

请求段页式虚存管理的动态地址转换机构由段表、页表和快表构成。

当前运行进程的段表起始地址已被操作系统置入段表控制寄存器，其动态地址转换过程如下：从逻辑地址出发，先以段号s和页号p作索引去查快表，如果找到，那么立即获得页p的页面号p’，并与位移d一 起拼装得到访问主存的物理地址，从而，完成了地址转换。若查快表失败，就要通过段表和 页表来做地址转换了，用段号s作索引，找到相应表目，由此得到s段的页表的起始地址s’，再以p作索引得到s段p页对应的表目，由此得到页面号p’；这时一方面把s段p页和页面号p’ 置换进快表，另一方面用p和d生成主存的物理地址，从而完成地址转换。 

上述过程是假设所需信息都在主存的情况下进行的，事实上，许多情况会产生，如查段表时，发现 s 段不在主存，于是产生“缺段中断”，引起操作系统查找 s 段在辅存的位置，并将该段页表调入主存；如查页表时，发现 s 段的 p 页不在主存，于是产生“缺页中断”，引起操作系统查找 s 段 p 页在辅存的位置，并将该页调入主存，当主存已无空闲页框时，就会导致淘汰页面。

#### 地址变换

<img src="https://s2.loli.net/2022/07/02/CT765jQUqs8cmNR.png" alt="image-20220628205922056" style="zoom:50%;" />

### 4.6.5 局部性原理和抖动问题

#### 局部性原理
各种内存管理方法在都需要内存和外存之间交换数据。

由模拟实验知道：在几乎所有程序的执行中，在一段时间内，CPU总是集中地访问程序中的某一个部分而不是随机地对程序的所有部分具有平均的访问概率。人们把这种现象称为局部性原理(principle of locality)。

**程序局部性原理（principle of locality）**： 在一段时间内，程序的执行仅局限于某个部分；相应地，所访问的存储空间也局限于某个区域内。它描述了一个进程中程序和数据引用的**簇聚性倾向**。这就使各种管理方式下的虚存实现成为可能。

程序局部性原理具体表现为**时间局部性**和**空间局部性**。

- 时间局部性：最近访问过的内存单元可能在不久的将来还要访问。产生时间局部性的典型原因是在程序中存在着大量的循环操作
- 空间局部性：最近访问过的内存单元附近的存储单元也最有可能被访问。即程序在一段时间内所访问的地址，可能集中在一定的范围内

#### 工作集

试验表明：任何程序在局部性地放入时，都有一个临界值的要求。当内存分配小于这个临界值时，内存和外存之间的数据交换次数将会急剧增加，出现抖动现象。而内存分配大于这个临界值时，就算再增加内存分配也不能显著减少交换次数。这个内存要求的临界值被称为工作集。

**工作集 (working set)** ：为确保每个进程每一时刻能够执行下去，在内存中必须有的最少页面数。

<img src="https://s2.loli.net/2022/07/02/2vEqM7NUFjCPnkK.png" alt="image-20220628210133235" style="zoom:33%;" />

#### 抖动问题

当系统给进程分配的内存小于所要求的工作集时，由于内外存之间数据交换非常频繁，大部分时间都花在内存和外存之间的来回调入调出上，造成CPU因等数据空转，使系统性能大大降低，这个现象称为抖动。

进程在执行过程中发生抖动的两种可能：

1. 并发进程所要求的工作集大于所分得的内存空间，这时，系统将无法正常工作
2. 存储管理程序为每个并发进程分配了足够的内存空间（大于工作集），但系统无法在开始执行前选择适当的程序段和数据进入内存。这时，只能依靠中断处理程序将所需要的程序和数据调入内存

解决抖动问题的办法：

1. 扩大分配的内存空间，使其大于工作集
2. 选择不同的淘汰算法


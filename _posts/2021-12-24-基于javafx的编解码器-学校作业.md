---
title: FexCodec-基于JavaFX和哈夫曼算法的解压缩编解码器-学校作业
author: fexla
date: 2021-12-24
categories: [编程, 工具开发]
tags: [编程, 工具开发, JavaFX, 作业]
---

记录一次学校作业...

## 需求

　　使用哈夫曼算法实现对文件的编码解码。

## 基本思路

　　我选择使用java作为编程语言，使用javafx作为ui框架。

　　将问题拆分成个3个部分：哈夫曼，BitSet操作，UI。

　　哈夫曼部分包括了一个哈夫曼树的构建，使用哈夫曼算法编码与解码，哈夫曼树序列化和反序列化。

　　BitSet部分是指自己根据要求实现一个二进制序列的数据对象。由于哈夫曼算法最终要把原始数据转换为不定长的二进制序列，最终合并转化为一系列字节写入文件，所以二进制序列的操作是不可避免的。java自带的bitset没有实现两个二进制串连接的操作所以只能自己写一个了。

　　UI部分使用javafx。UI中显示编码与解码两个页面，编码、解码需要选择填写原文件位置，和目标文件位置，编码需要额外填写原文件字符集。

　　整个程序接口和ui设计的时候留下扩展的余地，以备以后万一想往里加入其它编码方式的编解码。

　　我直观地猜测，正确定义了字符集后对应地构建哈夫曼树对于大部分的文件可以得到更好的压缩率。

　　初步的界面设计（初步到很丑，后面一定改）：

<img src="https://s4.ax1x.com/2021/12/24/TJUqEQ.png" alt="TJUqEQ.png" style="zoom:50%;" />

<img src="https://s4.ax1x.com/2021/12/24/TJaECR.png" alt="TJaECR.png" style="zoom:50%;" />

## 算法描述

### 哈夫曼算法

　　哈夫曼算法的意义在于能得到一颗最优二叉树。

　　（百度百科）给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

　　构建方法是：把给定的N个叶子节点放入一个集合中，每次取出权值最小的两个节点，合成一个新节点，权值为这两个节点的权值和，放入集合中，多次执行直到集合中只剩一个节点，最优二叉树就构建完成了，最后的节点就是二叉树的根节点。其中节点集合使用小根堆来维护，小根堆的特点是堆顶元素总是最小的，单次放入取出元素的时间复杂度都为O(logn)，因为构建哈夫曼树得到的节点总数为2倍叶子节点的数量减1，对集合操作的次数和叶子节点的个数成正比，所以最终时间复杂度为O(nlogn)。

　　最优二叉树可以用于优化基于判断的查找以及数据压缩。

　　伪代码表示：

```Pseudocode
turn leaves to nodes
loop if nodes.count > 1
	node_a = nodes.FindAndRemoveBiggest()
	node_b = nodes.FindAndRemoveBiggest()
	node_c.leftNode = node_a
	node_c.rightNode = node_b
	node_c.frequency = node_a.frequency + node_a.frequency
end loop
```

### BitSet的实现

　　BitSet的UML图如下：

![TGYebj.png](https://s4.ax1x.com/2021/12/23/TGYebj.png)

　　在BitSet中，使用long类型的数组来保存二进制序列，用一个long变量表示有效长度，二进制序列的位索引从word[0]的最低位开始计起。

　　append函数的作用是把一个二进制序列附加到一个二进制序列的前面，参数可以是一个二进制序列也可以是一个long值和一个int值表示有效长度。前者实际上是把要加的二进制序列拆分成若干个long类型的值然后调用后者。

　　appendlong的步骤是：

1.对储存数组第一个未填满的位置，使用掩码把超过了validLength（有效长度）处于高位的无效位进行过滤，过滤为0，放置高位上的无效位存在为1的位污染后面的运算。将1左移(validLength % 64)位再减1得到掩码。如：

```
有效位有75位
储存的words[1]为0000000000000000000000000000000001000000000000000001001110101010
	0000000000000000000000000000000001000000000000000001001110101010
&	0000000000000000000000000000000001000000000000000000011111111111
=	0000000000000000000000000000000001000000000000000000001110101010
```

2.将要附加的long值左移(64 - length)位，再右移(64 - length)位，将输入的二进制序列的无效位过滤。

3.将输入的long值左移(validLength % 64)，和数组第一个未填满的位置进行位或运算，并储存到数组里。

4.判断要储存输入的二进制序列是否需要数组的下一个位置：将原本的有效位长度和要添加的有效位长度相加，除以八，和原本的有效位长度除以8比较（两个都是向下取整），如果前者大则表示需要后面的位置储存。

5.如果4为真则把数组的下一位置设置为0并赋值为输入的long值右移(64 - (validLength % 64))位。

6.有效长度加上增加的长度。

伪代码：

```Pseudocode
ensureCapacity((int) (validLength + length-1 >>> 6)+1);
words[(int) (validLength >>> 6)] &= (1l << validLength % 64) - 1l;
value = value << (64 - length) >>> (64 - length);
words[(int) (validLength >>> 6)] |= value << validLength % 64;
//如果添加的数据不止影响在words的同一个位置
if (!(validLength + length - 1 >>> 6 == validLength - 1 >>> 6 || validLength % 64 == 0)) {
    words[(int) (validLength >>> 6) + 1] = 0;
    words[(int) (validLength >>> 6) + 1] |= value >>> (64 - (validLength % 64));
}
validLength += length;
```

## 一些实现细节

###  生成映射

　　哈夫曼树构建出来后，我不直接用树来进行编码与解码，而是使用深搜遍历哈夫曼树的所有叶节点，将整棵树转化为字符和二进制序列的映射（即编码），由两个哈希表组成。

　　具体细节是：声明一个临时的二进制序列bitset，使用深度优先搜索，当往左子树遍历时，给bitset末尾附加1；往左子树遍历时，给bitset末尾附加0；回溯时则将有效长度减少1位。这样这个二进制序列能随时地表示当前节点的二进制序列。当遍历到一个叶节点时就将该叶节点表示的字符和bitset的复制结果存入两个哈希表。

　　构建映射的时间复杂度为O(n)，n为节点数量，编码解码的时间复杂度都是O(n)，n为要编码、解码的字符串、二进制序列的长度，解码与使用树解码相同。 

### 二进制文件设计

　　编码后的二进制文件结构分为三个部分：原文件编码格式，哈夫曼树，编码后的二进制序列。

#### 原文件编码格式

　　直接储存字符集的名字来表示原文件编码格式。先是一个4字节的整数，表示名字的长度；然后就是名字的字符串（以Unicode的编码储存）。如果没有字符集则原本表示名字长度的位置写入0.

#### 哈夫曼树

　　首先写入树里字符的种类数量，使用一个4字节的整数储存；然后遍历字符到二进制序列的哈希表中的元素，每次遍历先写入字符，（是否是文字字符由上一步来确定。如果是文字字符，这里的字符会被转为char字符然后用Unicode格式储存，占用两个字节；如果是字节，则占用一个字节），然后写入二进制编码的有效长度，最后写入字符对应的二进制序列，字节长度为可以表示有效长度的最小长度。

![TJNOl6.png](https://s4.ax1x.com/2021/12/24/TJNOl6.png)

### 日志文件

　　我希望在编码与译码的时候可以生成一份明文报告，包括是否成功、各个操作耗时、哈夫曼树的具体形态等信息。

　　我用了比较简陋的实现方法：在编译码的接口上加一个OutputStreamWriter的参数，在编译码的类里添加一个void log(String)方法，如果我想把报告输出为文件，就给一个FileOutPutStream，如果我只想输出到控制台，就把System.out传进去，如果我不想输出，就不传参数进去，在log方法里跳过。

### 对字节和文本字符统一处理

　　由于编码的时候要处理把字节看做哈夫曼树的一个叶子和把文本字符看做一个叶子两种情况，所以考虑将两者抽象为一个东西，编解码的时候可以统一处理。我把抽象出来的东西命名为Cell，意思是构建哈夫曼树的基本字符。

　　Cell的设计如下：

![TJdVoQ.png](https://s4.ax1x.com/2021/12/24/TJdVoQ.png)

　　value的getter setter没什么好说的，hashCode和equal都是为了他们可以在hashmap中正常工作，getByteArray是因为译码的时候需要知道他们的字节表示。

　　光有个Cell还不行，还要有个CellReader，它的子类实现有ByteReader，CharReader，TxtReader，他们有不同的构造函数，参数是不同类型的输入流，在读取的时候使用这三种Reader来获得对应种类的Cell。

![TJ4AgK.png](https://s4.ax1x.com/2021/12/24/TJ4AgK.png)

　　用于读取字符的有两个类：CharReader和TxtReader。区别在于CharReader使用InputStream进行构造，在GetNext方法中读取两个字节然后组合成char值，只能读取Unicode字符；TxtReader使用InputStreamReader进行构造，InputStreamReader可以在流中进行编码转换，能读取所有字符。有CharReader的原因是TxtReader有些情况不能用，InputStreamReader会对读取的输入流缓存（而且没法取消），在编码的时候没什么问题，但是在反序列化哈夫曼树的时候，字符和数字交叉写在文件中，读取数字需要用字节流读取，读取字符要用CellReader读取，也就是说多个转换流共用一个输入流，如果InputStreamReader缓存了，输入流读到后面去了，其他转换流就会出问题。于是在编码的过程中使用TxtReader，在解码的过程中使用CharReader。编码的结果如果要存字符，一定使用Unicode编码，因为java中字符变量本身就是Unicode编码储存的，使用Unicode字符集读取与写入都只需要几次位运算就可以得到期望的结果。

## 具体实现

两个编码器解码器接口的定义：

编码器：

```java
package fexla.codec;

import java.io.IOException;
import java.io.InputStream;

public  interface Coder {
    byte[] Encode(InputStream is, String[] args) throws IOException;
}
```

解码器：

```java
package fexla.codec;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;

public interface Decoder {
    byte[] decode(InputStream is) throws IOException;
}
```

Cell：

```java
package fexla.codec.haffuman.cell;

/**
 * 表示最小的编解码的单位，
 * 比如在文本文件中，一个字就是一个Code
 * 在二进制文件中，一个字节就是一个Code
 */
public abstract class Cell<T> {
    public abstract T getValue();

    public abstract void setValue(T value);

    public abstract int hashCode();

    public abstract byte[] getByteArray();

    @Override
    public abstract boolean equals(Object obj) ;
}
```



```java
package fexla.codec.haffuman.cell;

public class ByteCell extends Cell<Byte> {
    private byte value;

    public Byte getValue() {
        return value;
    }

    public void setValue(Byte value) {
        this.value = value;
    }

    public ByteCell(byte value) {
        this.value = value;
    }

    @Override
    public int hashCode() {
        return value;
    }

    @Override
    public byte[] getByteArray() {
        return new byte[]{value};
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof ByteCell)
            return value == ((ByteCell) obj).getValue();
        return false;
    }
}
```



```java
package fexla.codec.haffuman.cell;

import java.io.CharArrayWriter;
import java.io.DataOutputStream;
import java.nio.charset.Charset;

public class TxtCell extends Cell<Character> {
    private char value;

    public Character getValue() {
        return value;
    }

    public void setValue(Character value) {
        this.value = value;
    }

    @Override
    public int hashCode() {
        return 0;
    }

    @Override
    public byte[] getByteArray() {
        byte[] b = new byte[2];
        b[0] = (byte) ((value >>> 8) & 0xFF);
        b[1] = (byte) ((value >>> 0) & 0xFF);
        return b;
    }

    public TxtCell(char value) {
        this.value = value;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof TxtCell)
            return value == ((TxtCell) obj).getValue();
        return false;
    }

    @Override
    public String toString() {
        return String.valueOf(value);
    }
}
```



```java
package fexla.codec.haffuman.cell.reader;

import fexla.codec.haffuman.cell.Cell;

import java.io.IOException;

public abstract class CellReader<T extends Cell> {
    public abstract T GetNext() throws IOException;
    public abstract void setSource(Object source);
}
```



```java
package fexla.codec.haffuman.cell.reader;

import fexla.codec.haffuman.cell.ByteCell;

import java.io.IOException;
import java.io.InputStream;

public class ByteReader extends CellReader<ByteCell> {
    private InputStream reader;

    public ByteReader(InputStream inputStream) {
        reader = inputStream;
    }

    @Override
    public ByteCell GetNext() throws IOException {
        int c = reader.read();
        if (c == -1) return null;
        return new ByteCell((byte) c);
    }

    @Override
    public void setSource(Object source) {
        if (source instanceof InputStream) {
            reader = (InputStream) source;
        }
    }
}
```



```java
package fexla.codec.haffuman.cell.reader;

import fexla.codec.haffuman.cell.TxtCell;

import java.io.IOException;
import java.io.InputStream;

public class CharReader extends CellReader<TxtCell> {
    private InputStream reader;

    public CharReader(InputStream inputStream) {
        reader = inputStream;
    }

    @Override
    public TxtCell GetNext() throws IOException {
        byte a = (byte) reader.read(), b = (byte) reader.read();
        char c = (char) (((a & 0xFF) << 8) | (b & 0xFF));
        return new TxtCell(c);
    }

    @Override
    public void setSource(Object source) {
        if (source instanceof InputStream) {
            reader = (InputStream) source;
        }
    }
}
```



```java
package fexla.codec.haffuman.cell.reader;

import fexla.codec.haffuman.cell.TxtCell;

import java.io.*;

public class TxtReader extends CellReader<TxtCell> {
    private InputStreamReader reader;

    public TxtReader(InputStreamReader inputStream) {
        reader = inputStream;
    }

    @Override
    public TxtCell GetNext() throws IOException {
            int value =  reader.read();
            if (value == -1) return null;
            return new TxtCell((char) value);
    }

    @Override
    public void setSource(Object source) {
        if (source instanceof InputStreamReader) {
            reader = (InputStreamReader) source;
        }
    }

}
```

数据结构的实现：

小根堆：

```java
package fexla.codec.util;

import java.util.ArrayList;
import java.util.List;

/// <summary>
/// 小根堆
/// compare反过来就是大根堆
/// </summary>
/// <typeparam name="T">堆内元素的类型</typeparam>
public class Heap<T extends Comparable> {
    //堆内元素
    List<T> num;

    public Heap() {
        this.num = new ArrayList<>();
    }

    //自下而上更新堆
    private void Update(int ind) {
        if (ind <= 0) return;
        if (num.get(ind).compareTo(num.get(ind / 2)) < 0) {
            Swap(ind, ind / 2);
            Update(ind / 2);
        }
    }

    //num.get().compareTo(num.get())
    //自上而下更新堆
    private void UpdateDown(int ind) {
        if (ind < 0 || ind * 2 + 1 >= num.size()) return;
        int n;
        if (ind * 2 + 2 >= num.size()) {
            n = ind * 2 + 1;
        } else {
            n = num.get(ind * 2 + 1).compareTo(num.get(ind * 2 + 2)) < 0 ? ind * 2 + 1 : ind * 2 + 2;
        }
        if (num.get(ind).compareTo(num.get(n)) > 0) {
            Swap(ind, n);
            UpdateDown(n);
        }
    }

    private void Swap(int ind1, int ind2) {
        T temp = num.get(ind1);
        num.set(ind1, num.get(ind2));
        num.set(ind2, temp);
    }

    //把一个元素压入堆中
    public void PushBack(T value) {
        num.add(value);
        Update(num.size() - 1);
    }

    public T Get(int ind) {
        if (ind >= num.size()) return null;
        return num.get(ind);
    }

    public T Top() {
        return num.get(0);
    }

    //取出堆顶元素
    public void Pop() {
        if (num.size() != 0) num.set(0, num.get(num.size() - 1));
        num.remove(num.size() - 1);
        UpdateDown(0);
    }

    //返回堆内元素的数量
    public int size() {
        return num.size();
    }

    public boolean isEmpty() {
        return num.isEmpty();
    }
}
```

​	二进制序列：

```java
package fexla.codec.util;

import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.Objects;

public class BitSet {
    public long[] words;
    private long validLength;
    public static final BitSet ONE = new BitSet(new long[]{1}, 1);
    public static final BitSet ZERO = new BitSet(new long[]{0}, 1);

    public BitSet(long[] words, long validLength) {
        this.words = words;
        this.validLength = validLength;
    }

    public BitSet(long validLength) {
        words = new long[(int) ((validLength - 1 >>> 6) + 1)];
    }

    public BitSet() {
        words = new long[]{0, 0};
        validLength = 0;
    }

    public void append(BitSet set) {
        long[] appendWords = set.words;
        for (int i = 0; i < set.validLength >>> 6; i++) {
            appendLong(appendWords[i], 64);
        }
        appendLong(appendWords[(int) (set.validLength >>> 6)], (int) (set.validLength % 64));
    }

    public void appendLong(long value, int length) {
        ensureCapacity((int) (validLength + length-1 >>> 6)+1);
        words[(int) (validLength >>> 6)] &= (1l << validLength % 64) - 1l;
        value = value << (64 - length) >>> (64 - length);
        words[(int) (validLength >>> 6)] |= value << validLength % 64;
        //如果添加的数据不止影响在word的同一个位置
        if (!(validLength + length - 1 >>> 6 == validLength - 1 >>> 6 || validLength % 64 == 0)) {
            words[(int) (validLength >>> 6) + 1] = 0;
            words[(int) (validLength >>> 6) + 1] |= value >>> (64 - (validLength % 64));
        }
        validLength += length;
    }


    private void ensureCapacity(int wordsRequired) {
        if (words.length < wordsRequired) {
            // 分配空间
            int request = Math.max(2 * words.length, wordsRequired);
            words = Arrays.copyOf(words, request);
        }

    }

    public int bitAt(long index) {
        return (int) ((words[(int) (index >>> 6)] & (1l << index % 64)) >>> index % 64);
    }

    public void bitSet(long index, int value) {
        if (value == 0) {
            words[(int) (index >>> 6)] &= (-1l - (1 << (index % 64)));
        } else {
            words[(int) (index >>> 6)] |= 1l << (index % 64);
        }
    }

    @Override
    public String toString() {
        StringBuilder str = new StringBuilder();
        for (long i = validLength - 1; i >= 0; i--) {
            str.append(bitAt(i));
        }
        return str.toString();
    }

    @Override
    public BitSet clone() {
        long[] cloneWords = Arrays.copyOf(words, (int) (validLength >>> 6) + 1);
        return new BitSet(cloneWords, validLength);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        BitSet bitSet = (BitSet) o;
        if (bitSet.validLength != validLength) return false;
        for (int i = 0; i < validLength >>> 6; i++) {
            if (bitSet.words[i] != words[i]) return false;
        }
        if (validLength % 64 == 0) return true;
        long lasta = (words[(int) (validLength >>> 6)] << (64 - validLength % 64)) >>> (64 - validLength % 64);
        long lastb = (bitSet.words[(int) (validLength >>> 6)] << (64 - validLength % 64)) >>> (64 - validLength % 64);
        return lasta == lastb;
    }

    @Override
    public int hashCode() {
        long h = "fexla".hashCode();
        for (int i = (int) (validLength >>> 6); --i >= 0; )
            h ^= words[i] * (i + 1);
        long last = (words[(int) (validLength >>> 6)] << (64 - validLength % 64)) >>> (64 - validLength % 64);
        h ^= last * ((validLength >>> 6) + 1);
        return (int) ((h >> 32) ^ h) ^ Long.hashCode(validLength);
    }

    public void narrow(long size) {
        validLength -= size;
        validLength = validLength > 0 ? validLength : 0;
        //清除原位置的值
        for (int i = 0; i < size >> 3; i++) {
            appendLong(0l, 64);
        }
        appendLong(0l, (int) (size % 64));
        validLength -= size;
        validLength = validLength > 0 ? validLength : 0;

    }

    /**
     * 将储存的二进制序列转为byte数组
     *
     * @return byte数组
     */
    public byte[] toByteArray() {
        if (validLength == 0) return new byte[0];
        int len = (int) ((validLength - 1) >>> 3) + 1;
        byte[] bytes = new byte[len];
        for (int i = 0; i < len; i++) {
            bytes[i] = (byte) (words[i >>> 3] >>> (8 * (i % 8)));
        }
        return bytes;
    }

    public static BitSet valueOf(byte[] bytes) {
        return valueOf(bytes, bytes.length * 8);
    }

    public static BitSet valueOf(byte[] bytes, int validLength) {
        if (validLength == 0) return new BitSet();
        long words[] = new long[(int) ((validLength - 1 >>> 6) + 1)];
        int byteLen = ((validLength - 1) >>> 3) + 1;
        for (int i = 0; i < byteLen; i++) {
            words[i >>> 3] |= (bytes[i] & 0xffl) << 8 * (i % 8);
        }
        return new BitSet(words, validLength);
    }

    private static final BigInteger bitSignificance = BigInteger.TWO.pow(64);//2^64,表示一个long位的权值
    private static final BigInteger signSignificance = BigInteger.TWO.pow(63);//2^63,表示一个long原本表示符号的位代表的值

    /**
     * 二进制序列转BigInteger
     *
     * @return
     */
    public BigInteger toBigInteger() {
        BigInteger result = BigInteger.ZERO;
        int length = (int) (validLength - 1 >>> 6) + 1;
        for (int i = length - 1; i >= 0; i--) {
            long value = words[i];
            if (value >= 0)
                result = result.multiply(bitSignificance).add(BigInteger.valueOf(value));
            else
                result = result.multiply(bitSignificance).add(BigInteger.valueOf(value & Long.MAX_VALUE)).add(signSignificance);
        }

        return result;
    }

    public void clear() {
        words = new long[words.length];
        validLength = 0;
    }

    public long getValidLength() {
        return validLength;
    }
}
```

哈夫曼编解码器类：

```java
package fexla.codec.haffuman;

import fexla.codec.Coder;
import fexla.codec.Decoder;
import fexla.codec.haffuman.cell.Cell;
import fexla.codec.haffuman.cell.reader.ByteReader;
import fexla.codec.haffuman.cell.reader.CellReader;
import fexla.codec.haffuman.cell.reader.CharReader;
import fexla.codec.haffuman.cell.reader.TxtReader;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.charset.UnsupportedCharsetException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Haffuman implements Coder, Decoder {
    private OutputStreamWriter logger;

    public Haffuman(OutputStreamWriter logger) {
        this.logger = logger;
    }

    @Override
    public byte[] Encode(InputStream is, String[] args) throws IOException {
        long startms = System.currentTimeMillis();
        CellReader cellReader = new ByteReader(is);
        Charset charset = null;
        //如果有设定编码，把cellReader赋值为一个特定编码集的TxtCellReader
        if (args != null && args.length != 0 && !args[0].equals("") && !args[0].equals("ANSI")) {
            try {
                charset = Charset.forName(args[0]);
                log("编码集为： " + charset.name() + "\n");
            } catch (UnsupportedCharsetException e) {
                logger.write("不支持的编码集\n");
            }
            cellReader = new TxtReader(new InputStreamReader(is, charset));
        }

        //读入的同时统计每个Cell出现的频率频率
        Cell b;
        List<Cell> cells = new ArrayList<>();
        Map<Cell, Integer> freq = new HashMap<>();
        while ((b = cellReader.GetNext()) != null) {
            cells.add(b);
            freq.compute(b, (key, value) -> value == null ? 1 : value + 1);
        }
        log("\n字符频率表：\n");
        int loop = 0;
        for (Map.Entry<Cell, Integer> entry : freq.entrySet()) {
            Cell cell = entry.getKey();
            Integer fre = entry.getValue();
            log(cell.getValue() + "  " + fre + "\t\t");
            if (++loop % 6 == 0) log("\n");
        }
        long treeStartms = System.currentTimeMillis();
        HaffumanTree tree = new HaffumanTree(freq);
        log("\n构建哈夫曼树耗时： " + (System.currentTimeMillis() - treeStartms) + "ms\n");
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        if (charset != null) {//写入源文件的编码集名字
            new DataOutputStream(baos).writeInt(charset.name().length());
            baos.write(charset.name().getBytes(StandardCharsets.UTF_16BE));
        } else {
            new DataOutputStream(baos).writeInt(0);
        }
        long encodeStartms = System.currentTimeMillis();
        tree.serialize(baos);//将哈夫曼树序列化并写入
        baos.write(tree.encode(cells).toByteArray());//写入编码得到的byte数组
        log("\n编码耗时： " + (System.currentTimeMillis() - encodeStartms) + "ms\n");
        baos.flush();
        baos.close();
        byte[] result = baos.toByteArray();
        log("\n总耗时： " + (System.currentTimeMillis() - startms) + "ms\n");
        return result;
    }


    @Override
    public byte[] decode(InputStream is) throws IOException {
        CellReader cellReader = new ByteReader(is);
        DataInputStream dataInputStream = new DataInputStream(is);
        int charsetNameLen = dataInputStream.readInt();//读取字符集名字的长度
        Charset charset = null;
        if (charsetNameLen != 0) {//读取字符集
            StringBuilder charsetName = new StringBuilder();
            for (int i = 0; i < charsetNameLen; i++) {
                charsetName.append(dataInputStream.readChar());
            }
            log("charset = " + charsetName);
            charset = Charset.forName(charsetName.toString());
            cellReader = new CharReader(is);
        }

        HaffumanTree tree = HaffumanTree.deSerialize(is, cellReader);//解码出哈夫曼树
        List<Cell> result = tree.decode(is);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ByteArrayOutputStream data = new ByteArrayOutputStream();
        for (Cell cell : result) {
            data.write(cell.getByteArray());
        }
//        new OutputStreamWriter(baos).write(charset.encode(CharBuffer.wrap(data.toByteArray())));
        if (charset == null)
            baos.write(data.toByteArray());
        else {
            baos.write(data.toString(StandardCharsets.UTF_16BE).getBytes(charset));
        }
        baos.flush();
        baos.close();
        data.flush();
        data.close();
        return baos.toByteArray();
    }

    private void log(String string) {
        if (logger != null) {
            try {
                logger.write(string);
            } catch (IOException e) {

            }
        }
    }

}
```

哈夫曼树：

```java
package fexla.codec.haffuman;

import fexla.codec.haffuman.cell.Cell;
import fexla.codec.haffuman.cell.reader.CellReader;
import fexla.codec.util.BitSet;
import fexla.codec.util.Heap;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HaffumanTree {
    private Map<Cell, BitSet> cell2Bit;
    private Map<BitSet, Cell> Bit2cell;
    private int height;//哈夫曼树的高度


    public HaffumanTree(Map<Cell, Integer> freq) {
        cell2Bit = new HashMap<>();
        Bit2cell = new HashMap<>();
        Heap<Node> heap = new Heap<>();
        freq.forEach((k, v) -> heap.PushBack(new Node(k, v)));//所有字符都压入小根堆
        while (heap.size() > 1) {
            Node a, b, parent;
            a = heap.Top();
            heap.Pop();
            b = heap.Top();
            heap.Pop();
            parent = new Node(a, b);
            heap.PushBack(parent);
        }
        Node root = heap.Top();
        height = root.height;
        search(root, new BitSet());
    }

    private HaffumanTree() {
        cell2Bit = new HashMap<>();
        Bit2cell = new HashMap<>();
    }

    /**
     * 编码
     *
     * @param cells
     * @return
     */
    public BitSet encode(List<Cell> cells) {
        BitSet bitSet = new BitSet();
        for (int i = 0; i < cells.size(); i++) {
            bitSet.append(cell2Bit.get(cells.get(i)));
        }
        BitSet length=new BitSet();
        long validLength= bitSet.getValidLength();
        validLength=Long.reverseBytes(validLength);
        length.appendLong(validLength,64);
        length.append(bitSet);
        bitSet=length;
        return bitSet;
    }

    /**
     * 解码
     *
     * @param is 输入流
     * @return 解码出来的内容
     * @throws IOException
     */
    public List<Cell> decode(InputStream is) throws IOException {
        BitSet bitSet = new BitSet();
        long length = new DataInputStream(is).readLong();
        for (int i = 0; i < (length-1>>>3)+1; i++) {
            bitSet.appendLong((byte)is.read(), 8);

        }
        BitSet tempSet = new BitSet();
        List<Cell> cells = new ArrayList<>();
        for (int i = 0; i < length; i++) {
            tempSet.appendLong(bitSet.bitAt(i), 1);
            Bit2cell.compute(tempSet, (k, v) -> {
                if (v != null) {
                    tempSet.clear();
                    cells.add(v);
                }
                return v;
            });
            if (tempSet.getValidLength() > height) {
                tempSet.clear();
            }
        }
        return cells;
    }

    /**
     * 递归深搜遍历所有节点，得到字符和编码后二进制的映射
     *
     * @param node
     * @param bitSet
     */
    private void search(Node node, BitSet bitSet) {
        if (node.cell != null) {
            cell2Bit.put(node.cell, bitSet.clone());
            Bit2cell.put(bitSet.clone(), node.cell);
            return;
        }
        if (node.left != null) {
            bitSet.append(BitSet.ONE);
            search(node.left, bitSet);
            bitSet.narrow(1);
        }
        if (node.right != null) {
            bitSet.append(BitSet.ZERO);
            search(node.right, bitSet);

            bitSet.narrow(1);
        }
    }

    /**
     * 将哈夫曼树序列化
     *
     * @return 字节数组
     */
    public byte[] serialize() throws IOException {
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        serialize(stream);
        return stream.toByteArray();
    }

    /**
     * 将哈夫曼树序列化，并输出到流中
     */
    public void serialize(OutputStream stream) throws IOException {
        DataOutputStream dataOutputStream = new DataOutputStream(stream);
        dataOutputStream.writeInt(cell2Bit.size());
        cell2Bit.forEach((k, v) -> {
            try {
                byte[] byteArray = k.getByteArray();
                dataOutputStream.write(byteArray);
                int validLength = (int) v.getValidLength();
                dataOutputStream.writeInt(validLength);
                dataOutputStream.write(v.toByteArray());
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
    }

    public static HaffumanTree deSerialize(InputStream stream, CellReader cellReader) throws IOException {
        HaffumanTree haffumanTree = new HaffumanTree();
        DataInputStream dataInputStream = new DataInputStream(stream);
        int size = dataInputStream.readInt();
        Map<Cell, BitSet> cell2Bit = haffumanTree.cell2Bit;
        Map<BitSet, Cell> Bit2cell = haffumanTree.Bit2cell;
        int height = 0;
        for (int i = 0; i < size; i++) {
            Cell cell = cellReader.GetNext();
            int validLength = dataInputStream.readInt();
            height = Math.max(height, validLength);
            byte[] bitsetByteArray = stream.readNBytes(((validLength - 1) >>> 3) + 1);
            BitSet bitSet = BitSet.valueOf(bitsetByteArray, validLength);
            cell2Bit.put(cell, bitSet.clone());
            Bit2cell.put(bitSet.clone(), cell);
        }
        haffumanTree.height = height;
        return haffumanTree;
    }

    public Map<Cell, BitSet> getCell2Bit() {
        return cell2Bit;
    }

    public void setCell2Bit(Map<Cell, BitSet> cell2Bit) {
        this.cell2Bit = cell2Bit;
    }

    public Map<BitSet, Cell> getBit2cell() {
        return Bit2cell;
    }

    public void setBit2cell(Map<BitSet, Cell> bit2cell) {
        Bit2cell = bit2cell;
    }

    public BitSet get(Cell key) {
        return cell2Bit.get(key);
    }

    @Override
    public String toString() {
        StringBuilder str = new StringBuilder();
        str.append(cell2Bit.size());
        str.append('\n');
        cell2Bit.forEach((k, v) -> {
            if (k != null)
                str.append(k.getValue()).
                        append("\t").
                        append(v).append("\n");
        });
        return str.toString();
    }

    class Node implements Comparable<Node> {
        public Cell cell;
        public int freq;
        public int height;//这个节点被创建时从子孙节点往上数的高度,用于统计整棵树的高度
        public Node left, right, parent;

        public Node(Cell cell, int freq) {
            this.cell = cell;
            this.freq = freq;
        }

        public Node(Node left, Node right) {
            this.left = left;
            this.right = right;
            left.parent = this;
            right.parent = this;
            freq = left.freq + right.freq;
            height = left.height > right.height ? left.height + 1 : right.height + 1;
        }

        @Override
        public int compareTo(Node o) {
            return freq - o.freq;
        }
    }
}
```

哈夫曼编码解码器：

```java
package fexla.codec.haffuman;

import fexla.codec.Coder;
import fexla.codec.Decoder;
import fexla.codec.haffuman.cell.Cell;
import fexla.codec.haffuman.cell.reader.ByteReader;
import fexla.codec.haffuman.cell.reader.CellReader;
import fexla.codec.haffuman.cell.reader.CharReader;
import fexla.codec.haffuman.cell.reader.TxtReader;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.charset.UnsupportedCharsetException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Haffuman implements Coder, Decoder {
    private OutputStreamWriter logger;

    public Haffuman(OutputStreamWriter logger) {
        this.logger = logger;
    }

    @Override
    public byte[] Encode(InputStream is, String[] args) throws IOException {
        long startms = System.currentTimeMillis();
        CellReader cellReader = new ByteReader(is);
        Charset charset = null;
        //如果有设定编码，把cellReader赋值为一个特定编码集的TxtCellReader
        if (args != null && args.length != 0 && !args[0].equals("") && !args[0].equals("ANSI")) {
            try {
                charset = Charset.forName(args[0]);
                log("编码集为： " + charset.name() + "\n");
            } catch (UnsupportedCharsetException e) {
                logger.write("不支持的编码集\n");
            }
            cellReader = new TxtReader(new InputStreamReader(is, charset));
        }

        //读入的同时统计每个Cell出现的频率频率
        Cell b;
        List<Cell> cells = new ArrayList<>();
        Map<Cell, Integer> freq = new HashMap<>();
        while ((b = cellReader.GetNext()) != null) {
            cells.add(b);
            freq.compute(b, (key, value) -> value == null ? 1 : value + 1);
        }
        log("\n字符频率表：\n");
        int loop = 0;
        for (Map.Entry<Cell, Integer> entry : freq.entrySet()) {
            Cell cell = entry.getKey();
            Integer fre = entry.getValue();
            log(cell.getValue() + "  " + fre + "\t\t");
            if (++loop % 6 == 0) log("\n");
        }
        long treeStartms = System.currentTimeMillis();
        HaffumanTree tree = new HaffumanTree(freq);
        log("\n构建哈夫曼树耗时： " + (System.currentTimeMillis() - treeStartms) + "ms\n");
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        if (charset != null) {//写入源文件的编码集名字
            new DataOutputStream(baos).writeInt(charset.name().length());
            baos.write(charset.name().getBytes(StandardCharsets.UTF_16BE));
        } else {
            new DataOutputStream(baos).writeInt(0);
        }
        long encodeStartms = System.currentTimeMillis();
        tree.serialize(baos);//将哈夫曼树序列化并写入
        baos.write(tree.encode(cells).toByteArray());//写入编码得到的byte数组
        log("\n编码耗时： " + (System.currentTimeMillis() - encodeStartms) + "ms\n");
        baos.flush();
        baos.close();
        byte[] result = baos.toByteArray();
        log("\n总耗时： " + (System.currentTimeMillis() - startms) + "ms\n");
        return result;
    }


    @Override
    public byte[] decode(InputStream is) throws IOException {
        CellReader cellReader = new ByteReader(is);
        DataInputStream dataInputStream = new DataInputStream(is);
        int charsetNameLen = dataInputStream.readInt();//读取字符集名字的长度
        Charset charset = null;
        if (charsetNameLen != 0) {//读取字符集
            StringBuilder charsetName = new StringBuilder();
            for (int i = 0; i < charsetNameLen; i++) {
                charsetName.append(dataInputStream.readChar());
            }
            log("charset = " + charsetName);
            charset = Charset.forName(charsetName.toString());
            cellReader = new CharReader(is);
        }

        HaffumanTree tree = HaffumanTree.deSerialize(is, cellReader);//解码出哈夫曼树
        List<Cell> result = tree.decode(is);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ByteArrayOutputStream data = new ByteArrayOutputStream();
        for (Cell cell : result) {
            data.write(cell.getByteArray());
        }
        if (charset == null)
            baos.write(data.toByteArray());
        else {
            baos.write(data.toString(StandardCharsets.UTF_16BE).getBytes(charset));
        }
        baos.flush();
        baos.close();
        data.flush();
        data.close();
        return baos.toByteArray();
    }

    private void log(String string) {
        if (logger != null) {
            try {
                logger.write(string);
            } catch (IOException e) {

            }
        }
    }

}
```

UI：

```xml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<AnchorPane minHeight="400.0" minWidth="600.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="fexla.codec.view.Controller">
    <children>
        <TabPane layoutX="6.0" layoutY="29.0" prefHeight="400.0" prefWidth="600.0" tabClosingPolicy="UNAVAILABLE" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
            <tabs>
                <Tab text="哈夫曼编码">
                    <content>
                        <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="180.0" prefWidth="200.0">
                            <children>
                                <VBox alignment="TOP_CENTER" prefHeight="342.0" prefWidth="600.0" spacing="20.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                    <children>
                                        <Button mnemonicParsing="false" onMouseReleased="#onSelectEncodeSource" text="选择文件" />
                                        <ChoiceBox fx:id="choiceBox" prefWidth="100.0" />
                              <TextField fx:id="textField" alignment="TOP_CENTER" maxWidth="200.0" prefHeight="24.0" prefWidth="200.0" />
                              <Button mnemonicParsing="false" onMouseReleased="#onEncode" text="编码" />
                                    </children>
                                    <padding>
                                        <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                                    </padding>
                                </VBox>
                            </children>
                        </AnchorPane>
                    </content>
                </Tab>
                <Tab text="哈夫曼解码">
                    <content>
                        <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="180.0" prefWidth="200.0">
                     <children>
                        <VBox alignment="TOP_CENTER" prefHeight="342.0" prefWidth="600.0" spacing="20.0">
                           <children>
                              <Button mnemonicParsing="false" onMouseReleased="#onSelectDecodingOrigin" text="选择文件" />
                              <Button mnemonicParsing="false" onMouseReleased="#onDecoding" text="解码" />
                           </children>
                           <padding>
                              <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                           </padding>
                        </VBox>
                     </children></AnchorPane>
                    </content>
                </Tab>
            </tabs>
        </TabPane>
    </children>
</AnchorPane>
```

```java
package fexla.codec.view;

import fexla.codec.Entrance;
import fexla.codec.haffuman.Haffuman;
import javafx.fxml.FXML;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.TextField;
import javafx.stage.FileChooser;

import java.io.*;

public class Controller {
    @FXML
    private ChoiceBox choiceBox;
    @FXML
    private TextField textField;

    public void initialize() {
        choiceBox.getItems().addAll(new String[]{"无编码", "UTF-8", "Unicode", "ASCII", "ISO_8859_1", "其他"});
        choiceBox.getSelectionModel().select(0);
        textField.setVisible(false);
        choiceBox.addEventHandler(ChoiceBox.ON_HIDING, event -> {
            if (choiceBox.getSelectionModel().getSelectedItem() == null) return;
            if (choiceBox.getSelectionModel().getSelectedItem().equals("其他")) {
                textField.setVisible(true);
            } else {
                textField.setVisible(false);
            }
        });
    }

    private File encodeSouce;
    private File encodeTarget;
    private File decodeOrigin;
    private File decodeTarget;

    @FXML
    private void onSelectEncodeSource() {
        encodeSouce = SelectFile(encodeSouce == null ? null : encodeSouce.getPath(),
                new FileChooser.ExtensionFilter("任意文件", "*.*"), true);
    }

    @FXML
    private void onEncode() {
        encodeTarget = SelectFile(encodeTarget == null ? null : encodeTarget.getPath(), new FileChooser.ExtensionFilter("哈夫曼编码二进制", "*.haf"), false);
        if (encodeTarget == null) return;
        if (encodeSouce == null) return;
        decodeOrigin = encodeTarget;
        String[] args = null;
        String str = (String) choiceBox.getSelectionModel().getSelectedItem();
        if (!str.equals("无编码")) {
            if (str.equals("其他")) {
                args = new String[]{textField.getText()};
            } else {
                args = new String[]{str};
            }
        }
        File logFile = new File(encodeTarget.getPath() + ".log");
        try {
            logFile.createNewFile();
            encodeTarget.createNewFile();
            OutputStreamWriter logger = new OutputStreamWriter(new FileOutputStream(logFile));
            FileInputStream is = new FileInputStream(encodeSouce);
            Haffuman haffuman = new Haffuman(logger);
            byte[] bytes = haffuman.Encode(is, args);
            FileOutputStream os = new FileOutputStream(encodeTarget);
            os.write(bytes);
            logger.flush();
            logger.close();
            is.close();
            os.flush();
            os.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private File SelectFile(String initalPath, FileChooser.ExtensionFilter filter, boolean isOpen) {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("打开");
        if (initalPath != null) fileChooser.setInitialDirectory(new File(initalPath).getParentFile());
        else fileChooser.setInitialDirectory(new File(System.getProperty("user.dir")));
        if (filter != null) fileChooser.getExtensionFilters().add(filter);
        File selectedFile;
        if (isOpen)
            selectedFile = fileChooser.showOpenDialog(Entrance.stage);
        else
            selectedFile = fileChooser.showSaveDialog(Entrance.stage);
        if (selectedFile == null) return null;
        return selectedFile;
    }

    @FXML
    private void onDecoding() {
        decodeTarget = SelectFile(decodeTarget == null ? null : decodeTarget.getPath(),
                new FileChooser.ExtensionFilter("任意文件", "*.*"), false);
        if (decodeTarget == null) return;
        if (decodeOrigin == null) return;

        File logFile = new File(decodeTarget.getPath() + ".log");
        try {
            logFile.createNewFile();
            decodeTarget.createNewFile();
            OutputStreamWriter logger = new OutputStreamWriter(new FileOutputStream(logFile));
            FileInputStream is = new FileInputStream(decodeOrigin);
            Haffuman haffuman = new Haffuman(logger);
            byte[] bytes = haffuman.decode(is);
            FileOutputStream os = new FileOutputStream(decodeTarget);
            os.write(bytes);
            logger.flush();
            logger.close();
            is.close();
            os.flush();
            os.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @FXML
    private void onSelectDecodingOrigin() {
        decodeOrigin = SelectFile(decodeOrigin == null ? null : decodeOrigin.getPath(),
                new FileChooser.ExtensionFilter("哈夫曼编码二进制", "*.haf"), true);

    }
}
```